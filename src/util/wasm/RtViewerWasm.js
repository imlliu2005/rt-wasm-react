/* eslint-disable */
import "globalthis/polyfill";
var globalThis = require("globalthis/polyfill")();
var RtViewer = (() => {
  var _scriptName = import.meta.url;

  return (
    function (moduleArg = {}) {
      var moduleRtn;

      var Module = Object.assign({}, moduleArg); var readyPromiseResolve, readyPromiseReject; var readyPromise = new Promise((resolve, reject) => { readyPromiseResolve = resolve; readyPromiseReject = reject });["getExceptionMessage", "$incrementExceptionRefcount", "$decrementExceptionRefcount", "_memory", "_Initialize", "_SetArgument", "_test", "_process_blob", "_read_from_idb", "___indirect_function_table", "_main", "onRuntimeInitialized"].forEach(prop => { if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) { Object.defineProperty(readyPromise, prop, { get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"), set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js") }) } }); var ENVIRONMENT_IS_WEB = true; var ENVIRONMENT_IS_WORKER = false; var ENVIRONMENT_IS_NODE = false; var ENVIRONMENT_IS_SHELL = false; if (Module["ENVIRONMENT"]) { throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)") } var moduleOverrides = Object.assign({}, Module); var arguments_ = []; var thisProgram = "./this.program"; var quit_ = (status, toThrow) => { throw toThrow }; var scriptDirectory = ""; function locateFile(path) { if (Module["locateFile"]) { return Module["locateFile"](path, scriptDirectory) } return scriptDirectory + path } var read_, readAsync, readBinary; if (ENVIRONMENT_IS_SHELL) { if (typeof process == "object" && typeof require === "function" || typeof window == "object" || typeof importScripts == "function") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)") } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = window.self.location.href } else if (typeof document != "undefined" && document.currentScript) { scriptDirectory = document.currentScript.src } if (_scriptName) { scriptDirectory = _scriptName } if (scriptDirectory.startsWith("blob:")) { scriptDirectory = "" } else { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1) } if (!(typeof window == "object" || typeof importScripts == "function")) throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"); { read_ = url => { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { readBinary = url => { var xhr = new XMLHttpRequest; xhr.open("GET", url, false); xhr.responseType = "arraybuffer"; xhr.send(null); return new Uint8Array(xhr.response) } } readAsync = (url, onload, onerror) => { var xhr = new XMLHttpRequest; xhr.open("GET", url, true); xhr.responseType = "arraybuffer"; xhr.onload = () => { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return } onerror() }; xhr.onerror = onerror; xhr.send(null) } } } else { throw new Error("environment detection error") } var out = Module["print"] || console.log.bind(console); var err = Module["printErr"] || console.error.bind(console); Object.assign(Module, moduleOverrides); moduleOverrides = null; checkIncomingModuleAPI(); if (Module["arguments"]) arguments_ = Module["arguments"]; legacyModuleProp("arguments", "arguments_"); if (Module["thisProgram"]) thisProgram = Module["thisProgram"]; legacyModuleProp("thisProgram", "thisProgram"); if (Module["quit"]) quit_ = Module["quit"]; legacyModuleProp("quit", "quit_"); assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"); assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"); assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"); assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"); assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)"); assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)"); assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)"); assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)"); assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"); legacyModuleProp("asm", "wasmExports"); legacyModuleProp("read", "read_"); legacyModuleProp("readAsync", "readAsync"); legacyModuleProp("readBinary", "readBinary"); legacyModuleProp("setWindowTitle", "setWindowTitle"); assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable."); assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable."); assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable."); var wasmBinary; if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"]; legacyModuleProp("wasmBinary", "wasmBinary"); if (typeof WebAssembly != "object") { err("no native wasm support detected") } var wasmMemory; var ABORT = false; var EXITSTATUS; function assert(condition, text) { if (!condition) { abort("Assertion failed" + (text ? ": " + text : "")) } } var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateMemoryViews() { var b = wasmMemory.buffer; Module["HEAP8"] = HEAP8 = new Int8Array(b); Module["HEAP16"] = HEAP16 = new Int16Array(b); Module["HEAPU8"] = HEAPU8 = new Uint8Array(b); Module["HEAPU16"] = HEAPU16 = new Uint16Array(b); Module["HEAP32"] = HEAP32 = new Int32Array(b); Module["HEAPU32"] = HEAPU32 = new Uint32Array(b); Module["HEAPF32"] = HEAPF32 = new Float32Array(b); Module["HEAPF64"] = HEAPF64 = new Float64Array(b) } assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"); assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, "JS engine does not provide full typed array support"); assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"); assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically"); function writeStackCookie() { var max = _emscripten_stack_get_end(); assert((max & 3) == 0); if (max == 0) { max += 4 } HEAPU32[max >> 2] = 34821223; HEAPU32[max + 4 >> 2] = 2310721022; HEAPU32[0 >> 2] = 1668509029 } function checkStackCookie() { if (ABORT) return; var max = _emscripten_stack_get_end(); if (max == 0) { max += 4 } var cookie1 = HEAPU32[max >> 2]; var cookie2 = HEAPU32[max + 4 >> 2]; if (cookie1 != 34821223 || cookie2 != 2310721022) { abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`) } if (HEAPU32[0 >> 2] != 1668509029) { abort("Runtime error: The application has corrupted its heap memory area (address zero)!") } } (function () { var h16 = new Int16Array(1); var h8 = new Int8Array(h16.buffer); h16[0] = 25459; if (h8[0] !== 115 || h8[1] !== 99) throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)" })(); var __ATPRERUN__ = []; var __ATINIT__ = []; var __ATMAIN__ = []; var __ATPOSTRUN__ = []; var runtimeInitialized = false; function preRun() { if (Module["preRun"]) { if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]]; while (Module["preRun"].length) { addOnPreRun(Module["preRun"].shift()) } } callRuntimeCallbacks(__ATPRERUN__) } function initRuntime() { assert(!runtimeInitialized); runtimeInitialized = true; checkStackCookie(); SOCKFS.root = FS.mount(SOCKFS, {}, null); if (!Module["noFSInit"] && !FS.init.initialized) FS.init(); FS.ignorePermissions = false; TTY.init(); callRuntimeCallbacks(__ATINIT__) } function preMain() { checkStackCookie(); callRuntimeCallbacks(__ATMAIN__) } function postRun() { checkStackCookie(); if (Module["postRun"]) { if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]]; while (Module["postRun"].length) { addOnPostRun(Module["postRun"].shift()) } } callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun(cb) { __ATPRERUN__.unshift(cb) } function addOnInit(cb) { __ATINIT__.unshift(cb) } function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb) } assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"); assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"); assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"); assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"); var runDependencies = 0; var runDependencyWatcher = null; var dependenciesFulfilled = null; var runDependencyTracking = {}; function getUniqueRunDependency(id) { var orig = id; while (1) { if (!runDependencyTracking[id]) return id; id = orig + Math.random() } } function addRunDependency(id) { runDependencies++; Module["monitorRunDependencies"]?.(runDependencies); if (id) { assert(!runDependencyTracking[id]); runDependencyTracking[id] = 1; if (runDependencyWatcher === null && typeof setInterval != "undefined") { runDependencyWatcher = setInterval(() => { if (ABORT) { clearInterval(runDependencyWatcher); runDependencyWatcher = null; return } var shown = false; for (var dep in runDependencyTracking) { if (!shown) { shown = true; err("still waiting on run dependencies:") } err(`dependency: ${dep}`) } if (shown) { err("(end of list)") } }, 1e4) } } else { err("warning: run dependency added without ID") } } function removeRunDependency(id) { runDependencies--; Module["monitorRunDependencies"]?.(runDependencies); if (id) { assert(runDependencyTracking[id]); delete runDependencyTracking[id] } else { err("warning: run dependency removed without ID") } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { var callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } } function abort(what) { Module["onAbort"]?.(what); what = "Aborted(" + what + ")"; err(what); ABORT = true; EXITSTATUS = 1; var e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e } var dataURIPrefix = "data:application/octet-stream;base64,"; var isDataURI = filename => filename.startsWith(dataURIPrefix); var isFileURI = filename => filename.startsWith("file://"); function createExportWrapper(name, nargs) { return (...args) => { assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`); var f = wasmExports[name]; assert(f, `exported native function \`${name}\` not found`); assert(args.length <= nargs, `native function \`${name}\` called with ${args.length} args but expects ${nargs}`); return f(...args) } } class EmscriptenEH extends Error { } class EmscriptenSjLj extends EmscriptenEH { } class CppException extends EmscriptenEH { constructor(excPtr) { super(excPtr); this.excPtr = excPtr; const excInfo = getExceptionMessage(excPtr); this.name = excInfo[0]; this.message = excInfo[1] } } function findWasmBinary() { if (Module["locateFile"]) { var f = "RtViewerWasm.wasm"; if (!isDataURI(f)) { return locateFile(f) } return f } return new URL("RtViewerWasm.wasm", import.meta.url).href } var wasmBinaryFile; function getBinarySync(file) { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } throw "both async and sync fetching of the wasm failed" } function getBinaryPromise(binaryFile) { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) { if (typeof fetch == "function") { return fetch(binaryFile, { credentials: "same-origin" }).then(response => { if (!response["ok"]) { throw `failed to load wasm binary file at '${binaryFile}'` } return response["arrayBuffer"]() }).catch(() => getBinarySync(binaryFile)) } } return Promise.resolve().then(() => getBinarySync(binaryFile)) } function instantiateArrayBuffer(binaryFile, imports, receiver) { return getBinaryPromise(binaryFile).then(binary => WebAssembly.instantiate(binary, imports)).then(receiver, reason => { err(`failed to asynchronously prepare wasm: ${reason}`); if (isFileURI(wasmBinaryFile)) { err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`) } abort(reason) }) } function instantiateAsync(binary, binaryFile, imports, callback) { if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") { return fetch(binaryFile, { credentials: "same-origin" }).then(response => { var result = WebAssembly.instantiateStreaming(response, imports); return result.then(callback, function (reason) { err(`wasm streaming compile failed: ${reason}`); err("falling back to ArrayBuffer instantiation"); return instantiateArrayBuffer(binaryFile, imports, callback) }) }) } return instantiateArrayBuffer(binaryFile, imports, callback) } function getWasmImports() { return { "env": wasmImports, "wasi_snapshot_preview1": wasmImports } } function createWasm() { var info = getWasmImports(); function receiveInstance(instance, module) { wasmExports = instance.exports; wasmMemory = wasmExports["memory"]; assert(wasmMemory, "memory not found in wasm exports"); updateMemoryViews(); wasmTable = wasmExports["__indirect_function_table"]; assert(wasmTable, "table not found in wasm exports"); addOnInit(wasmExports["__wasm_call_ctors"]); removeRunDependency("wasm-instantiate"); return wasmExports } addRunDependency("wasm-instantiate"); var trueModule = Module; function receiveInstantiationResult(result) { assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"); trueModule = null; receiveInstance(result["instance"]) } if (Module["instantiateWasm"]) { try { return Module["instantiateWasm"](info, receiveInstance) } catch (e) { err(`Module.instantiateWasm callback failed with error: ${e}`); readyPromiseReject(e) } } if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary(); instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject); return {} } var tempDouble; var tempI64; function legacyModuleProp(prop, newName, incoming = true) { if (!Object.getOwnPropertyDescriptor(Module, prop)) { Object.defineProperty(Module, prop, { configurable: true, get() { let extra = incoming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : ""; abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra) } }) } } function ignoredModuleProp(prop) { if (Object.getOwnPropertyDescriptor(Module, prop)) { abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`) } } function isExportedByForceFilesystem(name) { return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency" } function missingGlobal(sym, msg) { if (typeof globalThis != "undefined") { Object.defineProperty(globalThis, sym, { configurable: true, get() { warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`); return undefined } }) } } missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer"); missingGlobal("asm", "Please use wasmExports instead"); function missingLibrarySymbol(sym) { if (typeof globalThis != "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) { Object.defineProperty(globalThis, sym, { configurable: true, get() { var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`; var librarySymbol = sym; if (!librarySymbol.startsWith("_")) { librarySymbol = "$" + sym } msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`; if (isExportedByForceFilesystem(sym)) { msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you" } warnOnce(msg); return undefined } }) } unexportedRuntimeSymbol(sym) } function unexportedRuntimeSymbol(sym) { if (!Object.getOwnPropertyDescriptor(Module, sym)) { Object.defineProperty(Module, sym, { configurable: true, get() { var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`; if (isExportedByForceFilesystem(sym)) { msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you" } abort(msg) } }) } } var ASM_CONSTS = { 1356932: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("WasmModuleInitialized", false, false, undefined); window.dispatchEvent(customEvent) }, 1357103: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1357267: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1357431: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1357595: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1357759: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1357923: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1358087: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1358251: () => { const customEvent = document.createEvent("CustomEvent"); customEvent.initCustomEvent("StoneException", false, false, undefined); window.dispatchEvent(customEvent) }, 1358415: $0 => { document.getElementById(UTF8ToString($0)).oncontextmenu = function (event) { event.preventDefault() } } }; function ExitStatus(status) { this.name = "ExitStatus"; this.message = `Program terminated with exit(${status})`; this.status = status } var callRuntimeCallbacks = callbacks => { while (callbacks.length > 0) { callbacks.shift()(Module) } }; var stackSave = () => _emscripten_stack_get_current(); var stackRestore = val => __emscripten_stack_restore(val); var stackAlloc = sz => __emscripten_stack_alloc(sz); var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined; var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => { var endIdx = idx + maxBytesToRead; var endPtr = idx; while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr; if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) { return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr)) } var str = ""; while (idx < endPtr) { var u0 = heapOrArray[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } var u1 = heapOrArray[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } var u2 = heapOrArray[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { if ((u0 & 248) != 240) warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"); u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } return str }; var UTF8ToString = (ptr, maxBytesToRead) => { assert(typeof ptr == "number", `UTF8ToString expects a number (got ${typeof ptr})`); return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "" }; var getExceptionMessageCommon = ptr => { var sp = stackSave(); var type_addr_addr = stackAlloc(4); var message_addr_addr = stackAlloc(4); ___get_exception_message(ptr, type_addr_addr, message_addr_addr); var type_addr = HEAPU32[type_addr_addr >> 2]; var message_addr = HEAPU32[message_addr_addr >> 2]; var type = UTF8ToString(type_addr); _free(type_addr); var message; if (message_addr) { message = UTF8ToString(message_addr); _free(message_addr) } stackRestore(sp); return [type, message] }; var getExceptionMessage = ptr => getExceptionMessageCommon(ptr); Module["getExceptionMessage"] = getExceptionMessage; var noExitRuntime = Module["noExitRuntime"] || true; var ptrToString = ptr => { assert(typeof ptr === "number"); ptr >>>= 0; return "0x" + ptr.toString(16).padStart(8, "0") }; var warnOnce = text => { warnOnce.shown ||= {}; if (!warnOnce.shown[text]) { warnOnce.shown[text] = 1; err(text) } }; var ___assert_fail = (condition, filename, line, func) => { abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]) }; var exceptionCaught = []; var uncaughtExceptionCount = 0; var ___cxa_begin_catch = ptr => { var info = new ExceptionInfo(ptr); if (!info.get_caught()) { info.set_caught(true); uncaughtExceptionCount-- } info.set_rethrown(false); exceptionCaught.push(info); ___cxa_increment_exception_refcount(info.excPtr); return info.get_exception_ptr() }; var exceptionLast = 0; var ___cxa_end_catch = () => { _setThrew(0, 0); assert(exceptionCaught.length > 0); var info = exceptionCaught.pop(); ___cxa_decrement_exception_refcount(info.excPtr); exceptionLast = 0 }; class ExceptionInfo { constructor(excPtr) { this.excPtr = excPtr; this.ptr = excPtr - 24 } set_type(type) { HEAPU32[this.ptr + 4 >> 2] = type } get_type() { return HEAPU32[this.ptr + 4 >> 2] } set_destructor(destructor) { HEAPU32[this.ptr + 8 >> 2] = destructor } get_destructor() { return HEAPU32[this.ptr + 8 >> 2] } set_caught(caught) { caught = caught ? 1 : 0; HEAP8[this.ptr + 12] = caught } get_caught() { return HEAP8[this.ptr + 12] != 0 } set_rethrown(rethrown) { rethrown = rethrown ? 1 : 0; HEAP8[this.ptr + 13] = rethrown } get_rethrown() { return HEAP8[this.ptr + 13] != 0 } init(type, destructor) { this.set_adjusted_ptr(0); this.set_type(type); this.set_destructor(destructor) } set_adjusted_ptr(adjustedPtr) { HEAPU32[this.ptr + 16 >> 2] = adjustedPtr } get_adjusted_ptr() { return HEAPU32[this.ptr + 16 >> 2] } get_exception_ptr() { var isPointer = ___cxa_is_pointer_type(this.get_type()); if (isPointer) { return HEAPU32[this.excPtr >> 2] } var adjusted = this.get_adjusted_ptr(); if (adjusted !== 0) return adjusted; return this.excPtr } } var ___resumeException = ptr => { if (!exceptionLast) { exceptionLast = new CppException(ptr) } throw exceptionLast }; var setTempRet0 = val => __emscripten_tempret_set(val); var findMatchingCatch = args => { var thrown = exceptionLast?.excPtr; if (!thrown) { setTempRet0(0); return 0 } var info = new ExceptionInfo(thrown); info.set_adjusted_ptr(thrown); var thrownType = info.get_type(); if (!thrownType) { setTempRet0(0); return thrown } for (var arg in args) { var caughtType = args[arg]; if (caughtType === 0 || caughtType === thrownType) { break } var adjusted_ptr_addr = info.ptr + 16; if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) { setTempRet0(caughtType); return thrown } } setTempRet0(thrownType); return thrown }; var ___cxa_find_matching_catch_2 = () => findMatchingCatch([]); var ___cxa_find_matching_catch_3 = arg0 => findMatchingCatch([arg0]); var ___cxa_find_matching_catch_4 = (arg0, arg1) => findMatchingCatch([arg0, arg1]); var ___cxa_find_matching_catch_5 = (arg0, arg1, arg2) => findMatchingCatch([arg0, arg1, arg2]); var ___cxa_find_matching_catch_6 = (arg0, arg1, arg2, arg3) => findMatchingCatch([arg0, arg1, arg2, arg3]); var ___cxa_rethrow = () => { var info = exceptionCaught.pop(); if (!info) { abort("no exception to throw") } var ptr = info.excPtr; if (!info.get_rethrown()) { exceptionCaught.push(info); info.set_rethrown(true); info.set_caught(false); uncaughtExceptionCount++ } exceptionLast = new CppException(ptr); throw exceptionLast }; var ___cxa_throw = (ptr, type, destructor) => { var info = new ExceptionInfo(ptr); info.init(type, destructor); exceptionLast = new CppException(ptr); uncaughtExceptionCount++; throw exceptionLast }; var ___cxa_uncaught_exceptions = () => uncaughtExceptionCount; var initRandomFill = () => { if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") { return view => crypto.getRandomValues(view) } else abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };") }; var randomFill = view => (randomFill = initRandomFill())(view); var PATH = { isAbs: path => path.charAt(0) === "/", splitPath: filename => { var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; return splitPathRe.exec(filename).slice(1) }, normalizeArray: (parts, allowAboveRoot) => { var up = 0; for (var i = parts.length - 1; i >= 0; i--) { var last = parts[i]; if (last === ".") { parts.splice(i, 1) } else if (last === "..") { parts.splice(i, 1); up++ } else if (up) { parts.splice(i, 1); up-- } } if (allowAboveRoot) { for (; up; up--) { parts.unshift("..") } } return parts }, normalize: path => { var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/"; path = PATH.normalizeArray(path.split("/").filter(p => !!p), !isAbsolute).join("/"); if (!path && !isAbsolute) { path = "." } if (path && trailingSlash) { path += "/" } return (isAbsolute ? "/" : "") + path }, dirname: path => { var result = PATH.splitPath(path), root = result[0], dir = result[1]; if (!root && !dir) { return "." } if (dir) { dir = dir.substr(0, dir.length - 1) } return root + dir }, basename: path => { if (path === "/") return "/"; path = PATH.normalize(path); path = path.replace(/\/$/, ""); var lastSlash = path.lastIndexOf("/"); if (lastSlash === -1) return path; return path.substr(lastSlash + 1) }, join: (...paths) => PATH.normalize(paths.join("/")), join2: (l, r) => PATH.normalize(l + "/" + r) }; var PATH_FS = { resolve: (...args) => { var resolvedPath = "", resolvedAbsolute = false; for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) { var path = i >= 0 ? args[i] : FS.cwd(); if (typeof path != "string") { throw new TypeError("Arguments to path.resolve must be strings") } else if (!path) { return "" } resolvedPath = path + "/" + resolvedPath; resolvedAbsolute = PATH.isAbs(path) } resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(p => !!p), !resolvedAbsolute).join("/"); return (resolvedAbsolute ? "/" : "") + resolvedPath || "." }, relative: (from, to) => { from = PATH_FS.resolve(from).substr(1); to = PATH_FS.resolve(to).substr(1); function trim(arr) { var start = 0; for (; start < arr.length; start++) { if (arr[start] !== "") break } var end = arr.length - 1; for (; end >= 0; end--) { if (arr[end] !== "") break } if (start > end) return []; return arr.slice(start, end - start + 1) } var fromParts = trim(from.split("/")); var toParts = trim(to.split("/")); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break } } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push("..") } outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join("/") } }; var FS_stdin_getChar_buffer = []; var lengthBytesUTF8 = str => { var len = 0; for (var i = 0; i < str.length; ++i) { var c = str.charCodeAt(i); if (c <= 127) { len++ } else if (c <= 2047) { len += 2 } else if (c >= 55296 && c <= 57343) { len += 4; ++i } else { len += 3 } } return len }; var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => { assert(typeof str === "string", `stringToUTF8Array expects a string (got ${typeof str})`); if (!(maxBytesToWrite > 0)) return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { var u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++] = 192 | u >> 6; heap[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++] = 224 | u >> 12; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; if (u > 1114111) warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."); heap[outIdx++] = 240 | u >> 18; heap[outIdx++] = 128 | u >> 12 & 63; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } } heap[outIdx] = 0; return outIdx - startIdx }; function intArrayFromString(stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull) u8array.length = numBytesWritten; return u8array } var FS_stdin_getChar = () => { if (!FS_stdin_getChar_buffer.length) { var result = null; if (typeof window != "undefined" && typeof window.prompt == "function") { result = window.prompt("Input: "); if (result !== null) { result += "\n" } } else if (typeof readline == "function") { result = readline(); if (result !== null) { result += "\n" } } if (!result) { return null } FS_stdin_getChar_buffer = intArrayFromString(result, true) } return FS_stdin_getChar_buffer.shift() }; var TTY = { ttys: [], init() { }, shutdown() { }, register(dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops: ops }; FS.registerDevice(dev, TTY.stream_ops) }, stream_ops: { open(stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) { throw new FS.ErrnoError(43) } stream.tty = tty; stream.seekable = false }, close(stream) { stream.tty.ops.fsync(stream.tty) }, fsync(stream) { stream.tty.ops.fsync(stream.tty) }, read(stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) { throw new FS.ErrnoError(60) } var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = stream.tty.ops.get_char(stream.tty) } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write(stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) { throw new FS.ErrnoError(60) } try { for (var i = 0; i < length; i++) { stream.tty.ops.put_char(stream.tty, buffer[offset + i]) } } catch (e) { throw new FS.ErrnoError(29) } if (length) { stream.node.timestamp = Date.now() } return i } }, default_tty_ops: { get_char(tty) { return FS_stdin_getChar() }, put_char(tty, val) { if (val === null || val === 10) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0) tty.output.push(val) } }, fsync(tty) { if (tty.output && tty.output.length > 0) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } }, ioctl_tcgets(tty) { return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } }, ioctl_tcsets(tty, optional_actions, data) { return 0 }, ioctl_tiocgwinsz(tty) { return [24, 80] } }, default_tty1_ops: { put_char(tty, val) { if (val === null || val === 10) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0) tty.output.push(val) } }, fsync(tty) { if (tty.output && tty.output.length > 0) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } } }; var zeroMemory = (address, size) => { HEAPU8.fill(0, address, address + size); return address }; var mmapAlloc = size => { abort("internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported") }; var MEMFS = { ops_table: null, mount(mount) { return MEMFS.createNode(null, "/", 16384 | 511, 0) }, createNode(parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) { throw new FS.ErrnoError(63) } MEMFS.ops_table ||= { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } }; var node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) { node.node_ops = MEMFS.ops_table.dir.node; node.stream_ops = MEMFS.ops_table.dir.stream; node.contents = {} } else if (FS.isFile(node.mode)) { node.node_ops = MEMFS.ops_table.file.node; node.stream_ops = MEMFS.ops_table.file.stream; node.usedBytes = 0; node.contents = null } else if (FS.isLink(node.mode)) { node.node_ops = MEMFS.ops_table.link.node; node.stream_ops = MEMFS.ops_table.link.stream } else if (FS.isChrdev(node.mode)) { node.node_ops = MEMFS.ops_table.chrdev.node; node.stream_ops = MEMFS.ops_table.chrdev.stream } node.timestamp = Date.now(); if (parent) { parent.contents[name] = node; parent.timestamp = node.timestamp } return node }, getFileDataAsTypedArray(node) { if (!node.contents) return new Uint8Array(0); if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents) }, expandFileStorage(node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity) return; var CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0); if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0) }, resizeFileStorage(node, newSize) { if (node.usedBytes == newSize) return; if (newSize == 0) { node.contents = null; node.usedBytes = 0 } else { var oldContents = node.contents; node.contents = new Uint8Array(newSize); if (oldContents) { node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))) } node.usedBytes = newSize } }, node_ops: { getattr(node) { var attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) { attr.size = 4096 } else if (FS.isFile(node.mode)) { attr.size = node.usedBytes } else if (FS.isLink(node.mode)) { attr.size = node.link.length } else { attr.size = 0 } attr.atime = new Date(node.timestamp); attr.mtime = new Date(node.timestamp); attr.ctime = new Date(node.timestamp); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr }, setattr(node, attr) { if (attr.mode !== undefined) { node.mode = attr.mode } if (attr.timestamp !== undefined) { node.timestamp = attr.timestamp } if (attr.size !== undefined) { MEMFS.resizeFileStorage(node, attr.size) } }, lookup(parent, name) { throw FS.genericErrors[44] }, mknod(parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev) }, rename(old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) { var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (new_node) { for (var i in new_node.contents) { throw new FS.ErrnoError(55) } } } delete old_node.parent.contents[old_node.name]; old_node.parent.timestamp = Date.now(); old_node.name = new_name; new_dir.contents[new_name] = old_node; new_dir.timestamp = old_node.parent.timestamp; old_node.parent = new_dir }, unlink(parent, name) { delete parent.contents[name]; parent.timestamp = Date.now() }, rmdir(parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) { throw new FS.ErrnoError(55) } delete parent.contents[name]; parent.timestamp = Date.now() }, readdir(node) { var entries = [".", ".."]; for (var key of Object.keys(node.contents)) { entries.push(key) } return entries }, symlink(parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node }, readlink(node) { if (!FS.isLink(node.mode)) { throw new FS.ErrnoError(28) } return node.link } }, stream_ops: { read(stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes) return 0; var size = Math.min(stream.node.usedBytes - position, length); assert(size >= 0); if (size > 8 && contents.subarray) { buffer.set(contents.subarray(position, position + size), offset) } else { for (var i = 0; i < size; i++)buffer[offset + i] = contents[position + i] } return size }, write(stream, buffer, offset, length, position, canOwn) { assert(!(buffer instanceof ArrayBuffer)); if (buffer.buffer === HEAP8.buffer) { canOwn = false } if (!length) return 0; var node = stream.node; node.timestamp = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) { if (canOwn) { assert(position === 0, "canOwn must imply no weird position inside the file"); node.contents = buffer.subarray(offset, offset + length); node.usedBytes = length; return length } else if (node.usedBytes === 0 && position === 0) { node.contents = buffer.slice(offset, offset + length); node.usedBytes = length; return length } else if (position + length <= node.usedBytes) { node.contents.set(buffer.subarray(offset, offset + length), position); return length } } MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray) { node.contents.set(buffer.subarray(offset, offset + length), position) } else { for (var i = 0; i < length; i++) { node.contents[position + i] = buffer[offset + i] } } node.usedBytes = Math.max(node.usedBytes, position + length); return length }, llseek(stream, offset, whence) { var position = offset; if (whence === 1) { position += stream.position } else if (whence === 2) { if (FS.isFile(stream.node.mode)) { position += stream.node.usedBytes } } if (position < 0) { throw new FS.ErrnoError(28) } return position }, allocate(stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length); stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length) }, mmap(stream, length, position, prot, flags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } var ptr; var allocated; var contents = stream.node.contents; if (!(flags & 2) && contents.buffer === HEAP8.buffer) { allocated = false; ptr = contents.byteOffset } else { if (position > 0 || position + length < contents.length) { if (contents.subarray) { contents = contents.subarray(position, position + length) } else { contents = Array.prototype.slice.call(contents, position, position + length) } } allocated = true; ptr = mmapAlloc(length); if (!ptr) { throw new FS.ErrnoError(48) } HEAP8.set(contents, ptr) } return { ptr: ptr, allocated: allocated } }, msync(stream, buffer, offset, length, mmapFlags) { MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0 } } }; var asyncLoad = (url, onload, onerror, noRunDep) => { var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : ""; readAsync(url, arrayBuffer => { assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`); onload(new Uint8Array(arrayBuffer)); if (dep) removeRunDependency(dep) }, event => { if (onerror) { onerror() } else { throw `Loading data file "${url}" failed.` } }); if (dep) addRunDependency(dep) }; var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => { FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn) }; var preloadPlugins = Module["preloadPlugins"] || []; var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => { if (typeof Browser != "undefined") Browser.init(); var handled = false; preloadPlugins.forEach(plugin => { if (handled) return; if (plugin["canHandle"](fullname)) { plugin["handle"](byteArray, fullname, finish, onerror); handled = true } }); return handled }; var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => { var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; var dep = getUniqueRunDependency(`cp ${fullname}`); function processData(byteArray) { function finish(byteArray) { preFinish?.(); if (!dontCreateFile) { FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn) } onload?.(); removeRunDependency(dep) } if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => { onerror?.(); removeRunDependency(dep) })) { return } finish(byteArray) } addRunDependency(dep); if (typeof url == "string") { asyncLoad(url, processData, onerror) } else { processData(url) } }; var FS_modeStringToFlags = str => { var flagModes = { "r": 0, "r+": 2, "w": 512 | 64 | 1, "w+": 512 | 64 | 2, "a": 1024 | 64 | 1, "a+": 1024 | 64 | 2 }; var flags = flagModes[str]; if (typeof flags == "undefined") { throw new Error(`Unknown file open mode: ${str}`) } return flags }; var FS_getMode = (canRead, canWrite) => { var mode = 0; if (canRead) mode |= 292 | 73; if (canWrite) mode |= 146; return mode }; var ERRNO_MESSAGES = { 0: "Success", 1: "Arg list too long", 2: "Permission denied", 3: "Address already in use", 4: "Address not available", 5: "Address family not supported by protocol family", 6: "No more processes", 7: "Socket already connected", 8: "Bad file number", 9: "Trying to read unreadable message", 10: "Mount device busy", 11: "Operation canceled", 12: "No children", 13: "Connection aborted", 14: "Connection refused", 15: "Connection reset by peer", 16: "File locking deadlock error", 17: "Destination address required", 18: "Math arg out of domain of func", 19: "Quota exceeded", 20: "File exists", 21: "Bad address", 22: "File too large", 23: "Host is unreachable", 24: "Identifier removed", 25: "Illegal byte sequence", 26: "Connection already in progress", 27: "Interrupted system call", 28: "Invalid argument", 29: "I/O error", 30: "Socket is already connected", 31: "Is a directory", 32: "Too many symbolic links", 33: "Too many open files", 34: "Too many links", 35: "Message too long", 36: "Multihop attempted", 37: "File or path name too long", 38: "Network interface is not configured", 39: "Connection reset by network", 40: "Network is unreachable", 41: "Too many open files in system", 42: "No buffer space available", 43: "No such device", 44: "No such file or directory", 45: "Exec format error", 46: "No record locks available", 47: "The link has been severed", 48: "Not enough core", 49: "No message of desired type", 50: "Protocol not available", 51: "No space left on device", 52: "Function not implemented", 53: "Socket is not connected", 54: "Not a directory", 55: "Directory not empty", 56: "State not recoverable", 57: "Socket operation on non-socket", 59: "Not a typewriter", 60: "No such device or address", 61: "Value too large for defined data type", 62: "Previous owner died", 63: "Not super-user", 64: "Broken pipe", 65: "Protocol error", 66: "Unknown protocol", 67: "Protocol wrong type for socket", 68: "Math result not representable", 69: "Read only file system", 70: "Illegal seek", 71: "No such process", 72: "Stale file handle", 73: "Connection timed out", 74: "Text file busy", 75: "Cross-device link", 100: "Device not a stream", 101: "Bad font file fmt", 102: "Invalid slot", 103: "Invalid request code", 104: "No anode", 105: "Block device required", 106: "Channel number out of range", 107: "Level 3 halted", 108: "Level 3 reset", 109: "Link number out of range", 110: "Protocol driver not attached", 111: "No CSI structure available", 112: "Level 2 halted", 113: "Invalid exchange", 114: "Invalid request descriptor", 115: "Exchange full", 116: "No data (for no delay io)", 117: "Timer expired", 118: "Out of streams resources", 119: "Machine is not on the network", 120: "Package not installed", 121: "The object is remote", 122: "Advertise error", 123: "Srmount error", 124: "Communication error on send", 125: "Cross mount point (not really error)", 126: "Given log. name not unique", 127: "f.d. invalid for this operation", 128: "Remote address changed", 129: "Can   access a needed shared lib", 130: "Accessing a corrupted shared lib", 131: ".lib section in a.out corrupted", 132: "Attempting to link in too many libs", 133: "Attempting to exec a shared library", 135: "Streams pipe error", 136: "Too many users", 137: "Socket type not supported", 138: "Not supported", 139: "Protocol family not supported", 140: "Can't send after socket shutdown", 141: "Too many references", 142: "Host is down", 148: "No medium (in tape drive)", 156: "Level 2 not synchronized" }; var ERRNO_CODES = { "EPERM": 63, "ENOENT": 44, "ESRCH": 71, "EINTR": 27, "EIO": 29, "ENXIO": 60, "E2BIG": 1, "ENOEXEC": 45, "EBADF": 8, "ECHILD": 12, "EAGAIN": 6, "EWOULDBLOCK": 6, "ENOMEM": 48, "EACCES": 2, "EFAULT": 21, "ENOTBLK": 105, "EBUSY": 10, "EEXIST": 20, "EXDEV": 75, "ENODEV": 43, "ENOTDIR": 54, "EISDIR": 31, "EINVAL": 28, "ENFILE": 41, "EMFILE": 33, "ENOTTY": 59, "ETXTBSY": 74, "EFBIG": 22, "ENOSPC": 51, "ESPIPE": 70, "EROFS": 69, "EMLINK": 34, "EPIPE": 64, "EDOM": 18, "ERANGE": 68, "ENOMSG": 49, "EIDRM": 24, "ECHRNG": 106, "EL2NSYNC": 156, "EL3HLT": 107, "EL3RST": 108, "ELNRNG": 109, "EUNATCH": 110, "ENOCSI": 111, "EL2HLT": 112, "EDEADLK": 16, "ENOLCK": 46, "EBADE": 113, "EBADR": 114, "EXFULL": 115, "ENOANO": 104, "EBADRQC": 103, "EBADSLT": 102, "EDEADLOCK": 16, "EBFONT": 101, "ENOSTR": 100, "ENODATA": 116, "ETIME": 117, "ENOSR": 118, "ENONET": 119, "ENOPKG": 120, "EREMOTE": 121, "ENOLINK": 47, "EADV": 122, "ESRMNT": 123, "ECOMM": 124, "EPROTO": 65, "EMULTIHOP": 36, "EDOTDOT": 125, "EBADMSG": 9, "ENOTUNIQ": 126, "EBADFD": 127, "EREMCHG": 128, "ELIBACC": 129, "ELIBBAD": 130, "ELIBSCN": 131, "ELIBMAX": 132, "ELIBEXEC": 133, "ENOSYS": 52, "ENOTEMPTY": 55, "ENAMETOOLONG": 37, "ELOOP": 32, "EOPNOTSUPP": 138, "EPFNOSUPPORT": 139, "ECONNRESET": 15, "ENOBUFS": 42, "EAFNOSUPPORT": 5, "EPROTOTYPE": 67, "ENOTSOCK": 57, "ENOPROTOOPT": 50, "ESHUTDOWN": 140, "ECONNREFUSED": 14, "EADDRINUSE": 3, "ECONNABORTED": 13, "ENETUNREACH": 40, "ENETDOWN": 38, "ETIMEDOUT": 73, "EHOSTDOWN": 142, "EHOSTUNREACH": 23, "EINPROGRESS": 26, "EALREADY": 7, "EDESTADDRREQ": 17, "EMSGSIZE": 35, "EPROTONOSUPPORT": 66, "ESOCKTNOSUPPORT": 137, "EADDRNOTAVAIL": 4, "ENETRESET": 39, "EISCONN": 30, "ENOTCONN": 53, "ETOOMANYREFS": 141, "EUSERS": 136, "EDQUOT": 19, "ESTALE": 72, "ENOTSUP": 138, "ENOMEDIUM": 148, "EILSEQ": 25, "EOVERFLOW": 61, "ECANCELED": 11, "ENOTRECOVERABLE": 56, "EOWNERDEAD": 62, "ESTRPIPE": 135 }; var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class extends Error { constructor(errno) { super(ERRNO_MESSAGES[errno]); this.name = "ErrnoError"; this.errno = errno; for (var key in ERRNO_CODES) { if (ERRNO_CODES[key] === errno) { this.code = key; break } } } }, genericErrors: {}, filesystems: null, syncFSRequests: 0, FSStream: class { constructor() { this.shared = {} } get object() { return this.node } set object(val) { this.node = val } get isRead() { return (this.flags & 2097155) !== 1 } get isWrite() { return (this.flags & 2097155) !== 0 } get isAppend() { return this.flags & 1024 } get flags() { return this.shared.flags } set flags(val) { this.shared.flags = val } get position() { return this.shared.position } set position(val) { this.shared.position = val } }, FSNode: class { constructor(parent, name, mode, rdev) { if (!parent) { parent = this } this.parent = parent; this.mount = parent.mount; this.mounted = null; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.node_ops = {}; this.stream_ops = {}; this.rdev = rdev; this.readMode = 292 | 73; this.writeMode = 146 } get read() { return (this.mode & this.readMode) === this.readMode } set read(val) { val ? this.mode |= this.readMode : this.mode &= ~this.readMode } get write() { return (this.mode & this.writeMode) === this.writeMode } set write(val) { val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode } get isFolder() { return FS.isDir(this.mode) } get isDevice() { return FS.isChrdev(this.mode) } }, lookupPath(path, opts = {}) { path = PATH_FS.resolve(path); if (!path) return { path: "", node: null }; var defaults = { follow_mount: true, recurse_count: 0 }; opts = Object.assign(defaults, opts); if (opts.recurse_count > 8) { throw new FS.ErrnoError(32) } var parts = path.split("/").filter(p => !!p); var current = FS.root; var current_path = "/"; for (var i = 0; i < parts.length; i++) { var islast = i === parts.length - 1; if (islast && opts.parent) { break } current = FS.lookupNode(current, parts[i]); current_path = PATH.join2(current_path, parts[i]); if (FS.isMountpoint(current)) { if (!islast || islast && opts.follow_mount) { current = current.mounted.root } } if (!islast || opts.follow) { var count = 0; while (FS.isLink(current.mode)) { var link = FS.readlink(current_path); current_path = PATH_FS.resolve(PATH.dirname(current_path), link); var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 }); current = lookup.node; if (count++ > 40) { throw new FS.ErrnoError(32) } } } } return { path: current_path, node: current } }, getPath(node) { var path; while (true) { if (FS.isRoot(node)) { var mount = node.mount.mountpoint; if (!path) return mount; return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path } path = path ? `${node.name}/${path}` : node.name; node = node.parent } }, hashName(parentid, name) { var hash = 0; for (var i = 0; i < name.length; i++) { hash = (hash << 5) - hash + name.charCodeAt(i) | 0 } return (parentid + hash >>> 0) % FS.nameTable.length }, hashAddNode(node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node }, hashRemoveNode(node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) { FS.nameTable[hash] = node.name_next } else { var current = FS.nameTable[hash]; while (current) { if (current.name_next === node) { current.name_next = node.name_next; break } current = current.name_next } } }, lookupNode(parent, name) { var errCode = FS.mayLookup(parent); if (errCode) { throw new FS.ErrnoError(errCode) } var hash = FS.hashName(parent.id, name); for (var node = FS.nameTable[hash]; node; node = node.name_next) { var nodeName = node.name; if (node.parent.id === parent.id && nodeName === name) { return node } } return FS.lookup(parent, name) }, createNode(parent, name, mode, rdev) { assert(typeof parent == "object"); var node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node }, destroyNode(node) { FS.hashRemoveNode(node) }, isRoot(node) { return node === node.parent }, isMountpoint(node) { return !!node.mounted }, isFile(mode) { return (mode & 61440) === 32768 }, isDir(mode) { return (mode & 61440) === 16384 }, isLink(mode) { return (mode & 61440) === 40960 }, isChrdev(mode) { return (mode & 61440) === 8192 }, isBlkdev(mode) { return (mode & 61440) === 24576 }, isFIFO(mode) { return (mode & 61440) === 4096 }, isSocket(mode) { return (mode & 49152) === 49152 }, flagsToPermissionString(flag) { var perms = ["r", "w", "rw"][flag & 3]; if (flag & 512) { perms += "w" } return perms }, nodePermissions(node, perms) { if (FS.ignorePermissions) { return 0 } if (perms.includes("r") && !(node.mode & 292)) { return 2 } else if (perms.includes("w") && !(node.mode & 146)) { return 2 } else if (perms.includes("x") && !(node.mode & 73)) { return 2 } return 0 }, mayLookup(dir) { if (!FS.isDir(dir.mode)) return 54; var errCode = FS.nodePermissions(dir, "x"); if (errCode) return errCode; if (!dir.node_ops.lookup) return 2; return 0 }, mayCreate(dir, name) { try { var node = FS.lookupNode(dir, name); return 20 } catch (e) { } return FS.nodePermissions(dir, "wx") }, mayDelete(dir, name, isdir) { var node; try { node = FS.lookupNode(dir, name) } catch (e) { return e.errno } var errCode = FS.nodePermissions(dir, "wx"); if (errCode) { return errCode } if (isdir) { if (!FS.isDir(node.mode)) { return 54 } if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) { return 10 } } else { if (FS.isDir(node.mode)) { return 31 } } return 0 }, mayOpen(node, flags) { if (!node) { return 44 } if (FS.isLink(node.mode)) { return 32 } else if (FS.isDir(node.mode)) { if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) { return 31 } } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)) }, MAX_OPEN_FDS: 4096, nextfd() { for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) { if (!FS.streams[fd]) { return fd } } throw new FS.ErrnoError(33) }, getStreamChecked(fd) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) } return stream }, getStream: fd => FS.streams[fd], createStream(stream, fd = -1) { stream = Object.assign(new FS.FSStream, stream); if (fd == -1) { fd = FS.nextfd() } stream.fd = fd; FS.streams[fd] = stream; return stream }, closeStream(fd) { FS.streams[fd] = null }, dupStream(origStream, fd = -1) { var stream = FS.createStream(origStream, fd); stream.stream_ops?.dup?.(stream); return stream }, chrdev_stream_ops: { open(stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; stream.stream_ops.open?.(stream) }, llseek() { throw new FS.ErrnoError(70) } }, major: dev => dev >> 8, minor: dev => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice(dev, ops) { FS.devices[dev] = { stream_ops: ops } }, getDevice: dev => FS.devices[dev], getMounts(mount) { var mounts = []; var check = [mount]; while (check.length) { var m = check.pop(); mounts.push(m); check.push(...m.mounts) } return mounts }, syncfs(populate, callback) { if (typeof populate == "function") { callback = populate; populate = false } FS.syncFSRequests++; if (FS.syncFSRequests > 1) { err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`) } var mounts = FS.getMounts(FS.root.mount); var completed = 0; function doCallback(errCode) { assert(FS.syncFSRequests > 0); FS.syncFSRequests--; return callback(errCode) } function done(errCode) { if (errCode) { if (!done.errored) { done.errored = true; return doCallback(errCode) } return } if (++completed >= mounts.length) { doCallback(null) } } mounts.forEach(mount => { if (!mount.type.syncfs) { return done(null) } mount.type.syncfs(mount, populate, done) }) }, mount(type, opts, mountpoint) { if (typeof type == "string") { throw type } var root = mountpoint === "/"; var pseudo = !mountpoint; var node; if (root && FS.root) { throw new FS.ErrnoError(10) } else if (!root && !pseudo) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); mountpoint = lookup.path; node = lookup.node; if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } if (!FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } } var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }; var mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) { FS.root = mountRoot } else if (node) { node.mounted = mount; if (node.mount) { node.mount.mounts.push(mount) } } return mountRoot }, unmount(mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) { throw new FS.ErrnoError(28) } var node = lookup.node; var mount = node.mounted; var mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach(hash => { var current = FS.nameTable[hash]; while (current) { var next = current.name_next; if (mounts.includes(current.mount)) { FS.destroyNode(current) } current = next } }); node.mounted = null; var idx = node.mount.mounts.indexOf(mount); assert(idx !== -1); node.mount.mounts.splice(idx, 1) }, lookup(parent, name) { return parent.node_ops.lookup(parent, name) }, mknod(path, mode, dev) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); if (!name || name === "." || name === "..") { throw new FS.ErrnoError(28) } var errCode = FS.mayCreate(parent, name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.mknod) { throw new FS.ErrnoError(63) } return parent.node_ops.mknod(parent, name, mode, dev) }, create(path, mode) { mode = mode !== undefined ? mode : 438; mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0) }, mkdir(path, mode) { mode = mode !== undefined ? mode : 511; mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0) }, mkdirTree(path, mode) { var dirs = path.split("/"); var d = ""; for (var i = 0; i < dirs.length; ++i) { if (!dirs[i]) continue; d += "/" + dirs[i]; try { FS.mkdir(d, mode) } catch (e) { if (e.errno != 20) throw e } } }, mkdev(path, mode, dev) { if (typeof dev == "undefined") { dev = mode; mode = 438 } mode |= 8192; return FS.mknod(path, mode, dev) }, symlink(oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) { throw new FS.ErrnoError(44) } var lookup = FS.lookupPath(newpath, { parent: true }); var parent = lookup.node; if (!parent) { throw new FS.ErrnoError(44) } var newname = PATH.basename(newpath); var errCode = FS.mayCreate(parent, newname); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.symlink) { throw new FS.ErrnoError(63) } return parent.node_ops.symlink(parent, newname, oldpath) }, rename(old_path, new_path) { var old_dirname = PATH.dirname(old_path); var new_dirname = PATH.dirname(new_path); var old_name = PATH.basename(old_path); var new_name = PATH.basename(new_path); var lookup, old_dir, new_dir; lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node; if (!old_dir || !new_dir) throw new FS.ErrnoError(44); if (old_dir.mount !== new_dir.mount) { throw new FS.ErrnoError(75) } var old_node = FS.lookupNode(old_dir, old_name); var relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== ".") { throw new FS.ErrnoError(28) } relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== ".") { throw new FS.ErrnoError(55) } var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (old_node === new_node) { return } var isdir = FS.isDir(old_node.mode); var errCode = FS.mayDelete(old_dir, old_name, isdir); if (errCode) { throw new FS.ErrnoError(errCode) } errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!old_dir.node_ops.rename) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) { throw new FS.ErrnoError(10) } if (new_dir !== old_dir) { errCode = FS.nodePermissions(old_dir, "w"); if (errCode) { throw new FS.ErrnoError(errCode) } } FS.hashRemoveNode(old_node); try { old_dir.node_ops.rename(old_node, new_dir, new_name) } catch (e) { throw e } finally { FS.hashAddNode(old_node) } }, rmdir(path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, true); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.rmdir) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } parent.node_ops.rmdir(parent, name); FS.destroyNode(node) }, readdir(path) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; if (!node.node_ops.readdir) { throw new FS.ErrnoError(54) } return node.node_ops.readdir(node) }, unlink(path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; if (!parent) { throw new FS.ErrnoError(44) } var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var errCode = FS.mayDelete(parent, name, false); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.unlink) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } parent.node_ops.unlink(parent, name); FS.destroyNode(node) }, readlink(path) { var lookup = FS.lookupPath(path); var link = lookup.node; if (!link) { throw new FS.ErrnoError(44) } if (!link.node_ops.readlink) { throw new FS.ErrnoError(28) } return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)) }, stat(path, dontFollow) { var lookup = FS.lookupPath(path, { follow: !dontFollow }); var node = lookup.node; if (!node) { throw new FS.ErrnoError(44) } if (!node.node_ops.getattr) { throw new FS.ErrnoError(63) } return node.node_ops.getattr(node) }, lstat(path) { return FS.stat(path, true) }, chmod(path, mode, dontFollow) { var node; if (typeof path == "string") { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() }) }, lchmod(path, mode) { FS.chmod(path, mode, true) }, fchmod(fd, mode) { var stream = FS.getStreamChecked(fd); FS.chmod(stream.node, mode) }, chown(path, uid, gid, dontFollow) { var node; if (typeof path == "string") { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } node.node_ops.setattr(node, { timestamp: Date.now() }) }, lchown(path, uid, gid) { FS.chown(path, uid, gid, true) }, fchown(fd, uid, gid) { var stream = FS.getStreamChecked(fd); FS.chown(stream.node, uid, gid) }, truncate(path, len) { if (len < 0) { throw new FS.ErrnoError(28) } var node; if (typeof path == "string") { var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } if (FS.isDir(node.mode)) { throw new FS.ErrnoError(31) } if (!FS.isFile(node.mode)) { throw new FS.ErrnoError(28) } var errCode = FS.nodePermissions(node, "w"); if (errCode) { throw new FS.ErrnoError(errCode) } node.node_ops.setattr(node, { size: len, timestamp: Date.now() }) }, ftruncate(fd, len) { var stream = FS.getStreamChecked(fd); if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(28) } FS.truncate(stream.node, len) }, utime(path, atime, mtime) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }) }, open(path, flags, mode) { if (path === "") { throw new FS.ErrnoError(44) } flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags; mode = typeof mode == "undefined" ? 438 : mode; if (flags & 64) { mode = mode & 4095 | 32768 } else { mode = 0 } var node; if (typeof path == "object") { node = path } else { path = PATH.normalize(path); try { var lookup = FS.lookupPath(path, { follow: !(flags & 131072) }); node = lookup.node } catch (e) { } } var created = false; if (flags & 64) { if (node) { if (flags & 128) { throw new FS.ErrnoError(20) } } else { node = FS.mknod(path, mode, 0); created = true } } if (!node) { throw new FS.ErrnoError(44) } if (FS.isChrdev(node.mode)) { flags &= ~512 } if (flags & 65536 && !FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } if (!created) { var errCode = FS.mayOpen(node, flags); if (errCode) { throw new FS.ErrnoError(errCode) } } if (flags & 512 && !created) { FS.truncate(node, 0) } flags &= ~(128 | 512 | 131072); var stream = FS.createStream({ node: node, path: FS.getPath(node), flags: flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }); if (stream.stream_ops.open) { stream.stream_ops.open(stream) } if (Module["logReadFiles"] && !(flags & 1)) { if (!FS.readFiles) FS.readFiles = {}; if (!(path in FS.readFiles)) { FS.readFiles[path] = 1 } } return stream }, close(stream) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (stream.getdents) stream.getdents = null; try { if (stream.stream_ops.close) { stream.stream_ops.close(stream) } } catch (e) { throw e } finally { FS.closeStream(stream.fd) } stream.fd = null }, isClosed(stream) { return stream.fd === null }, llseek(stream, offset, whence) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (!stream.seekable || !stream.stream_ops.llseek) { throw new FS.ErrnoError(70) } if (whence != 0 && whence != 1 && whence != 2) { throw new FS.ErrnoError(28) } stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position }, read(stream, buffer, offset, length, position) { assert(offset >= 0); if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.read) { throw new FS.ErrnoError(28) } var seeking = typeof position != "undefined"; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking) stream.position += bytesRead; return bytesRead }, write(stream, buffer, offset, length, position, canOwn) { assert(offset >= 0); if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.write) { throw new FS.ErrnoError(28) } if (stream.seekable && stream.flags & 1024) { FS.llseek(stream, 0, 2) } var seeking = typeof position != "undefined"; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking) stream.position += bytesWritten; return bytesWritten }, allocate(stream, offset, length) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (offset < 0 || length <= 0) { throw new FS.ErrnoError(28) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(43) } if (!stream.stream_ops.allocate) { throw new FS.ErrnoError(138) } stream.stream_ops.allocate(stream, offset, length) }, mmap(stream, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) { throw new FS.ErrnoError(2) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(2) } if (!stream.stream_ops.mmap) { throw new FS.ErrnoError(43) } return stream.stream_ops.mmap(stream, length, position, prot, flags) }, msync(stream, buffer, offset, length, mmapFlags) { assert(offset >= 0); if (!stream.stream_ops.msync) { return 0 } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags) }, ioctl(stream, cmd, arg) { if (!stream.stream_ops.ioctl) { throw new FS.ErrnoError(59) } return stream.stream_ops.ioctl(stream, cmd, arg) }, readFile(path, opts = {}) { opts.flags = opts.flags || 0; opts.encoding = opts.encoding || "binary"; if (opts.encoding !== "utf8" && opts.encoding !== "binary") { throw new Error(`Invalid encoding type "${opts.encoding}"`) } var ret; var stream = FS.open(path, opts.flags); var stat = FS.stat(path); var length = stat.size; var buf = new Uint8Array(length); FS.read(stream, buf, 0, length, 0); if (opts.encoding === "utf8") { ret = UTF8ArrayToString(buf, 0) } else if (opts.encoding === "binary") { ret = buf } FS.close(stream); return ret }, writeFile(path, data, opts = {}) { opts.flags = opts.flags || 577; var stream = FS.open(path, opts.flags, opts.mode); if (typeof data == "string") { var buf = new Uint8Array(lengthBytesUTF8(data) + 1); var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length); FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn) } else if (ArrayBuffer.isView(data)) { FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn) } else { throw new Error("Unsupported data type") } FS.close(stream) }, cwd: () => FS.currentPath, chdir(path) { var lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) { throw new FS.ErrnoError(44) } if (!FS.isDir(lookup.node.mode)) { throw new FS.ErrnoError(54) } var errCode = FS.nodePermissions(lookup.node, "x"); if (errCode) { throw new FS.ErrnoError(errCode) } FS.currentPath = lookup.path }, createDefaultDirectories() { FS.mkdir("/tmp"); FS.mkdir("/home"); FS.mkdir("/home/web_user") }, createDefaultDevices() { FS.mkdir("/dev"); FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer, offset, length, pos) => length }); FS.mkdev("/dev/null", FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev("/dev/tty", FS.makedev(5, 0)); FS.mkdev("/dev/tty1", FS.makedev(6, 0)); var randomBuffer = new Uint8Array(1024), randomLeft = 0; var randomByte = () => { if (randomLeft === 0) { randomLeft = randomFill(randomBuffer).byteLength } return randomBuffer[--randomLeft] }; FS.createDevice("/dev", "random", randomByte); FS.createDevice("/dev", "urandom", randomByte); FS.mkdir("/dev/shm"); FS.mkdir("/dev/shm/tmp") }, createSpecialDirectories() { FS.mkdir("/proc"); var proc_self = FS.mkdir("/proc/self"); FS.mkdir("/proc/self/fd"); FS.mount({ mount() { var node = FS.createNode(proc_self, "fd", 16384 | 511, 73); node.node_ops = { lookup(parent, name) { var fd = +name; var stream = FS.getStreamChecked(fd); var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path } }; ret.parent = ret; return ret } }; return node } }, {}, "/proc/self/fd") }, createStandardStreams() { if (Module["stdin"]) { FS.createDevice("/dev", "stdin", Module["stdin"]) } else { FS.symlink("/dev/tty", "/dev/stdin") } if (Module["stdout"]) { FS.createDevice("/dev", "stdout", null, Module["stdout"]) } else { FS.symlink("/dev/tty", "/dev/stdout") } if (Module["stderr"]) { FS.createDevice("/dev", "stderr", null, Module["stderr"]) } else { FS.symlink("/dev/tty1", "/dev/stderr") } var stdin = FS.open("/dev/stdin", 0); var stdout = FS.open("/dev/stdout", 1); var stderr = FS.open("/dev/stderr", 1); assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`); assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`); assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`) }, staticInit() { [44].forEach(code => { FS.genericErrors[code] = new FS.ErrnoError(code); FS.genericErrors[code].stack = "<generic error, no stack>" }); FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, "/"); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { "MEMFS": MEMFS } }, init(input, output, error) { assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"); FS.init.initialized = true; Module["stdin"] = input || Module["stdin"]; Module["stdout"] = output || Module["stdout"]; Module["stderr"] = error || Module["stderr"]; FS.createStandardStreams() }, quit() { FS.init.initialized = false; _fflush(0); for (var i = 0; i < FS.streams.length; i++) { var stream = FS.streams[i]; if (!stream) { continue } FS.close(stream) } }, findObject(path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); if (!ret.exists) { return null } return ret.object }, analyzePath(path, dontResolveLastLink) { try { var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); path = lookup.path } catch (e) { } var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try { var lookup = FS.lookupPath(path, { parent: true }); ret.parentExists = true; ret.parentPath = lookup.path; ret.parentObject = lookup.node; ret.name = PATH.basename(path); lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); ret.exists = true; ret.path = lookup.path; ret.object = lookup.node; ret.name = lookup.node.name; ret.isRoot = lookup.path === "/" } catch (e) { ret.error = e.errno } return ret }, createPath(parent, path, canRead, canWrite) { parent = typeof parent == "string" ? parent : FS.getPath(parent); var parts = path.split("/").reverse(); while (parts.length) { var part = parts.pop(); if (!part) continue; var current = PATH.join2(parent, part); try { FS.mkdir(current) } catch (e) { } parent = current } return current }, createFile(parent, name, properties, canRead, canWrite) { var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name); var mode = FS_getMode(canRead, canWrite); return FS.create(path, mode) }, createDataFile(parent, name, data, canRead, canWrite, canOwn) { var path = name; if (parent) { parent = typeof parent == "string" ? parent : FS.getPath(parent); path = name ? PATH.join2(parent, name) : parent } var mode = FS_getMode(canRead, canWrite); var node = FS.create(path, mode); if (data) { if (typeof data == "string") { var arr = new Array(data.length); for (var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i); data = arr } FS.chmod(node, mode | 146); var stream = FS.open(node, 577); FS.write(stream, data, 0, data.length, 0, canOwn); FS.close(stream); FS.chmod(node, mode) } }, createDevice(parent, name, input, output) { var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name); var mode = FS_getMode(!!input, !!output); if (!FS.createDevice.major) FS.createDevice.major = 64; var dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open(stream) { stream.seekable = false }, close(stream) { if (output?.buffer?.length) { output(10) } }, read(stream, buffer, offset, length, pos) { var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = input() } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write(stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) { try { output(buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(29) } } if (length) { stream.node.timestamp = Date.now() } return i } }); return FS.mkdev(path, mode, dev) }, forceLoadFile(obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true; if (typeof XMLHttpRequest != "undefined") { throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.") } else if (read_) { try { obj.contents = intArrayFromString(read_(obj.url), true); obj.usedBytes = obj.contents.length } catch (e) { throw new FS.ErrnoError(29) } } else { throw new Error("Cannot load without read() or XMLHttpRequest.") } }, createLazyFile(parent, name, url, canRead, canWrite) { class LazyUint8Array { constructor() { this.lengthKnown = false; this.chunks = [] } get(idx) { if (idx > this.length - 1 || idx < 0) { return undefined } var chunkOffset = idx % this.chunkSize; var chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset] } setDataGetter(getter) { this.getter = getter } cacheLength() { var xhr = new XMLHttpRequest; xhr.open("HEAD", url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status); var datalength = Number(xhr.getResponseHeader("Content-length")); var header; var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes"; var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip"; var chunkSize = 1024 * 1024; if (!hasByteServing) chunkSize = datalength; var doXHR = (from, to) => { if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!"); if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!"); var xhr = new XMLHttpRequest; xhr.open("GET", url, false); if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to); xhr.responseType = "arraybuffer"; if (xhr.overrideMimeType) { xhr.overrideMimeType("text/plain; charset=x-user-defined") } xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status); if (xhr.response !== undefined) { return new Uint8Array(xhr.response || []) } return intArrayFromString(xhr.responseText || "", true) }; var lazyArray = this; lazyArray.setDataGetter(chunkNum => { var start = chunkNum * chunkSize; var end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] == "undefined") { lazyArray.chunks[chunkNum] = doXHR(start, end) } if (typeof lazyArray.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!"); return lazyArray.chunks[chunkNum] }); if (usesGzip || !datalength) { chunkSize = datalength = 1; datalength = this.getter(0).length; chunkSize = datalength; out("LazyFiles on gzip forces download of the whole file when length is accessed") } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true } get length() { if (!this.lengthKnown) { this.cacheLength() } return this._length } get chunkSize() { if (!this.lengthKnown) { this.cacheLength() } return this._chunkSize } } if (typeof XMLHttpRequest != "undefined") { if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; var lazyArray = new LazyUint8Array; var properties = { isDevice: false, contents: lazyArray } } else { var properties = { isDevice: false, url: url } } var node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) { node.contents = properties.contents } else if (properties.url) { node.contents = null; node.url = properties.url } Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length } } }); var stream_ops = {}; var keys = Object.keys(node.stream_ops); keys.forEach(key => { var fn = node.stream_ops[key]; stream_ops[key] = (...args) => { FS.forceLoadFile(node); return fn(...args) } }); function writeChunks(stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= contents.length) return 0; var size = Math.min(contents.length - position, length); assert(size >= 0); if (contents.slice) { for (var i = 0; i < size; i++) { buffer[offset + i] = contents[position + i] } } else { for (var i = 0; i < size; i++) { buffer[offset + i] = contents.get(position + i) } } return size } stream_ops.read = (stream, buffer, offset, length, position) => { FS.forceLoadFile(node); return writeChunks(stream, buffer, offset, length, position) }; stream_ops.mmap = (stream, length, position, prot, flags) => { FS.forceLoadFile(node); var ptr = mmapAlloc(length); if (!ptr) { throw new FS.ErrnoError(48) } writeChunks(stream, HEAP8, ptr, length, position); return { ptr: ptr, allocated: true } }; node.stream_ops = stream_ops; return node }, absolutePath() { abort("FS.absolutePath has been removed; use PATH_FS.resolve instead") }, createFolder() { abort("FS.createFolder has been removed; use FS.mkdir instead") }, createLink() { abort("FS.createLink has been removed; use FS.symlink instead") }, joinPath() { abort("FS.joinPath has been removed; use PATH.join instead") }, mmapAlloc() { abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc") }, standardizePath() { abort("FS.standardizePath has been removed; use PATH.normalize instead") } }; var SOCKFS = { mount(mount) { Module["websocket"] = Module["websocket"] && "object" === typeof Module["websocket"] ? Module["websocket"] : {}; Module["websocket"]._callbacks = {}; Module["websocket"]["on"] = function (event, callback) { if ("function" === typeof callback) { this._callbacks[event] = callback } return this }; Module["websocket"].emit = function (event, param) { if ("function" === typeof this._callbacks[event]) { this._callbacks[event].call(this, param) } }; return FS.createNode(null, "/", 16384 | 511, 0) }, createSocket(family, type, protocol) { type &= ~526336; var streaming = type == 1; if (streaming && protocol && protocol != 6) { throw new FS.ErrnoError(66) } var sock = { family: family, type: type, protocol: protocol, server: null, error: null, peers: {}, pending: [], recv_queue: [], sock_ops: SOCKFS.websocket_sock_ops }; var name = SOCKFS.nextname(); var node = FS.createNode(SOCKFS.root, name, 49152, 0); node.sock = sock; var stream = FS.createStream({ path: name, node: node, flags: 2, seekable: false, stream_ops: SOCKFS.stream_ops }); sock.stream = stream; return sock }, getSocket(fd) { var stream = FS.getStream(fd); if (!stream || !FS.isSocket(stream.node.mode)) { return null } return stream.node.sock }, stream_ops: { poll(stream) { var sock = stream.node.sock; return sock.sock_ops.poll(sock) }, ioctl(stream, request, varargs) { var sock = stream.node.sock; return sock.sock_ops.ioctl(sock, request, varargs) }, read(stream, buffer, offset, length, position) { var sock = stream.node.sock; var msg = sock.sock_ops.recvmsg(sock, length); if (!msg) { return 0 } buffer.set(msg.buffer, offset); return msg.buffer.length }, write(stream, buffer, offset, length, position) { var sock = stream.node.sock; return sock.sock_ops.sendmsg(sock, buffer, offset, length) }, close(stream) { var sock = stream.node.sock; sock.sock_ops.close(sock) } }, nextname() { if (!SOCKFS.nextname.current) { SOCKFS.nextname.current = 0 } return "socket[" + SOCKFS.nextname.current++ + "]" }, websocket_sock_ops: { createPeer(sock, addr, port) { var ws; if (typeof addr == "object") { ws = addr; addr = null; port = null } if (ws) { if (ws._socket) { addr = ws._socket.remoteAddress; port = ws._socket.remotePort } else { var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url); if (!result) { throw new Error("WebSocket URL must be in the format ws(s)://address:port") } addr = result[1]; port = parseInt(result[2], 10) } } else { try { var runtimeConfig = Module["websocket"] && "object" === typeof Module["websocket"]; var url = "ws:#".replace("#", "//"); if (runtimeConfig) { if ("string" === typeof Module["websocket"]["url"]) { url = Module["websocket"]["url"] } } if (url === "ws://" || url === "wss://") { var parts = addr.split("/"); url = url + parts[0] + ":" + port + "/" + parts.slice(1).join("/") } var subProtocols = "binary"; if (runtimeConfig) { if ("string" === typeof Module["websocket"]["subprotocol"]) { subProtocols = Module["websocket"]["subprotocol"] } } var opts = undefined; if (subProtocols !== "null") { subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */); opts = subProtocols } if (runtimeConfig && null === Module["websocket"]["subprotocol"]) { subProtocols = "null"; opts = undefined } var WebSocketConstructor; { WebSocketConstructor = WebSocket } ws = new WebSocketConstructor(url, opts); ws.binaryType = "arraybuffer" } catch (e) { throw new FS.ErrnoError(23) } } var peer = { addr: addr, port: port, socket: ws, dgram_send_queue: [] }; SOCKFS.websocket_sock_ops.addPeer(sock, peer); SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer); if (sock.type === 2 && typeof sock.sport != "undefined") { peer.dgram_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (sock.sport & 65280) >> 8, sock.sport & 255])) } return peer }, getPeer(sock, addr, port) { return sock.peers[addr + ":" + port] }, addPeer(sock, peer) { sock.peers[peer.addr + ":" + peer.port] = peer }, removePeer(sock, peer) { delete sock.peers[peer.addr + ":" + peer.port] }, handlePeerEvents(sock, peer) { var first = true; var handleOpen = function () { Module["websocket"].emit("open", sock.stream.fd); try { var queued = peer.dgram_send_queue.shift(); while (queued) { peer.socket.send(queued); queued = peer.dgram_send_queue.shift() } } catch (e) { peer.socket.close() } }; function handleMessage(data) { if (typeof data == "string") { var encoder = new TextEncoder; data = encoder.encode(data) } else { assert(data.byteLength !== undefined); if (data.byteLength == 0) { return } data = new Uint8Array(data) } var wasfirst = first; first = false; if (wasfirst && data.length === 10 && data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 && data[4] === "p".charCodeAt(0) && data[5] === "o".charCodeAt(0) && data[6] === "r".charCodeAt(0) && data[7] === "t".charCodeAt(0)) { var newport = data[8] << 8 | data[9]; SOCKFS.websocket_sock_ops.removePeer(sock, peer); peer.port = newport; SOCKFS.websocket_sock_ops.addPeer(sock, peer); return } sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data }); Module["websocket"].emit("message", sock.stream.fd) } if (ENVIRONMENT_IS_NODE) { peer.socket.on("open", handleOpen); peer.socket.on("message", function (data, isBinary) { if (!isBinary) { return } handleMessage(new Uint8Array(data).buffer) }); peer.socket.on("close", function () { Module["websocket"].emit("close", sock.stream.fd) }); peer.socket.on("error", function (error) { sock.error = 14; Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]) }) } else { peer.socket.onopen = handleOpen; peer.socket.onclose = function () { Module["websocket"].emit("close", sock.stream.fd) }; peer.socket.onmessage = function peer_socket_onmessage(event) { handleMessage(event.data) }; peer.socket.onerror = function (error) { sock.error = 14; Module["websocket"].emit("error", [sock.stream.fd, sock.error, "ECONNREFUSED: Connection refused"]) } } }, poll(sock) { if (sock.type === 1 && sock.server) { return sock.pending.length ? 64 | 1 : 0 } var mask = 0; var dest = sock.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) : null; if (sock.recv_queue.length || !dest || dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) { mask |= 64 | 1 } if (!dest || dest && dest.socket.readyState === dest.socket.OPEN) { mask |= 4 } if (dest && dest.socket.readyState === dest.socket.CLOSING || dest && dest.socket.readyState === dest.socket.CLOSED) { mask |= 16 } return mask }, ioctl(sock, request, arg) { switch (request) { case 21531: var bytes = 0; if (sock.recv_queue.length) { bytes = sock.recv_queue[0].data.length } HEAP32[arg >> 2] = bytes; return 0; default: return 28 } }, close(sock) { if (sock.server) { try { sock.server.close() } catch (e) { } sock.server = null } var peers = Object.keys(sock.peers); for (var i = 0; i < peers.length; i++) { var peer = sock.peers[peers[i]]; try { peer.socket.close() } catch (e) { } SOCKFS.websocket_sock_ops.removePeer(sock, peer) } return 0 }, bind(sock, addr, port) { if (typeof sock.saddr != "undefined" || typeof sock.sport != "undefined") { throw new FS.ErrnoError(28) } sock.saddr = addr; sock.sport = port; if (sock.type === 2) { if (sock.server) { sock.server.close(); sock.server = null } try { sock.sock_ops.listen(sock, 0) } catch (e) { if (!(e.name === "ErrnoError")) throw e; if (e.errno !== 138) throw e } } }, connect(sock, addr, port) { if (sock.server) { throw new FS.ErrnoError(138) } if (typeof sock.daddr != "undefined" && typeof sock.dport != "undefined") { var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport); if (dest) { if (dest.socket.readyState === dest.socket.CONNECTING) { throw new FS.ErrnoError(7) } else { throw new FS.ErrnoError(30) } } } var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port); sock.daddr = peer.addr; sock.dport = peer.port; throw new FS.ErrnoError(26) }, listen(sock, backlog) { if (!ENVIRONMENT_IS_NODE) { throw new FS.ErrnoError(138) } }, accept(listensock) { if (!listensock.server || !listensock.pending.length) { throw new FS.ErrnoError(28) } var newsock = listensock.pending.shift(); newsock.stream.flags = listensock.stream.flags; return newsock }, getname(sock, peer) { var addr, port; if (peer) { if (sock.daddr === undefined || sock.dport === undefined) { throw new FS.ErrnoError(53) } addr = sock.daddr; port = sock.dport } else { addr = sock.saddr || 0; port = sock.sport || 0 } return { addr: addr, port: port } }, sendmsg(sock, buffer, offset, length, addr, port) { if (sock.type === 2) { if (addr === undefined || port === undefined) { addr = sock.daddr; port = sock.dport } if (addr === undefined || port === undefined) { throw new FS.ErrnoError(17) } } else { addr = sock.daddr; port = sock.dport } var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port); if (sock.type === 1) { if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) { throw new FS.ErrnoError(53) } else if (dest.socket.readyState === dest.socket.CONNECTING) { throw new FS.ErrnoError(6) } } if (ArrayBuffer.isView(buffer)) { offset += buffer.byteOffset; buffer = buffer.buffer } var data; data = buffer.slice(offset, offset + length); if (sock.type === 2) { if (!dest || dest.socket.readyState !== dest.socket.OPEN) { if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) { dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port) } dest.dgram_send_queue.push(data); return length } } try { dest.socket.send(data); return length } catch (e) { throw new FS.ErrnoError(28) } }, recvmsg(sock, length) { if (sock.type === 1 && sock.server) { throw new FS.ErrnoError(53) } var queued = sock.recv_queue.shift(); if (!queued) { if (sock.type === 1) { var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport); if (!dest) { throw new FS.ErrnoError(53) } if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) { return null } throw new FS.ErrnoError(6) } throw new FS.ErrnoError(6) } var queuedLength = queued.data.byteLength || queued.data.length; var queuedOffset = queued.data.byteOffset || 0; var queuedBuffer = queued.data.buffer || queued.data; var bytesRead = Math.min(length, queuedLength); var res = { buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead), addr: queued.addr, port: queued.port }; if (sock.type === 1 && bytesRead < queuedLength) { var bytesRemaining = queuedLength - bytesRead; queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining); sock.recv_queue.unshift(queued) } return res } } }; var getSocketFromFD = fd => { var socket = SOCKFS.getSocket(fd); if (!socket) throw new FS.ErrnoError(8); return socket }; var inetNtop4 = addr => (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255); var inetNtop6 = ints => { var str = ""; var word = 0; var longest = 0; var lastzero = 0; var zstart = 0; var len = 0; var i = 0; var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16]; var hasipv4 = true; var v4part = ""; for (i = 0; i < 5; i++) { if (parts[i] !== 0) { hasipv4 = false; break } } if (hasipv4) { v4part = inetNtop4(parts[6] | parts[7] << 16); if (parts[5] === -1) { str = "::ffff:"; str += v4part; return str } if (parts[5] === 0) { str = "::"; if (v4part === "0.0.0.0") v4part = ""; if (v4part === "0.0.0.1") v4part = "1"; str += v4part; return str } } for (word = 0; word < 8; word++) { if (parts[word] === 0) { if (word - lastzero > 1) { len = 0 } lastzero = word; len++ } if (len > longest) { longest = len; zstart = word - longest + 1 } } for (word = 0; word < 8; word++) { if (longest > 1) { if (parts[word] === 0 && word >= zstart && word < zstart + longest) { if (word === zstart) { str += ":"; if (zstart === 0) str += ":" } continue } } str += Number(_ntohs(parts[word] & 65535)).toString(16); str += word < 7 ? ":" : "" } return str }; var readSockaddr = (sa, salen) => { var family = HEAP16[sa >> 1]; var port = _ntohs(HEAPU16[sa + 2 >> 1]); var addr; switch (family) { case 2: if (salen !== 16) { return { errno: 28 } } addr = HEAP32[sa + 4 >> 2]; addr = inetNtop4(addr); break; case 10: if (salen !== 28) { return { errno: 28 } } addr = [HEAP32[sa + 8 >> 2], HEAP32[sa + 12 >> 2], HEAP32[sa + 16 >> 2], HEAP32[sa + 20 >> 2]]; addr = inetNtop6(addr); break; default: return { errno: 5 } }return { family: family, addr: addr, port: port } }; var inetPton4 = str => { var b = str.split("."); for (var i = 0; i < 4; i++) { var tmp = Number(b[i]); if (isNaN(tmp)) return null; b[i] = tmp } return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0 }; var jstoi_q = str => parseInt(str); var inetPton6 = str => { var words; var w, offset, z; var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i; var parts = []; if (!valid6regx.test(str)) { return null } if (str === "::") { return [0, 0, 0, 0, 0, 0, 0, 0] } if (str.startsWith("::")) { str = str.replace("::", "Z:") } else { str = str.replace("::", ":Z:") } if (str.indexOf(".") > 0) { str = str.replace(new RegExp("[.]", "g"), ":"); words = str.split(":"); words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256; words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256; words = words.slice(0, words.length - 2) } else { words = str.split(":") } offset = 0; z = 0; for (w = 0; w < words.length; w++) { if (typeof words[w] == "string") { if (words[w] === "Z") { for (z = 0; z < 8 - words.length + 1; z++) { parts[w + z] = 0 } offset = z - 1 } else { parts[w + offset] = _htons(parseInt(words[w], 16)) } } else { parts[w + offset] = words[w] } } return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]] }; var DNS = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name(name) { var res = inetPton4(name); if (res !== null) { return name } res = inetPton6(name); if (res !== null) { return name } var addr; if (DNS.address_map.addrs[name]) { addr = DNS.address_map.addrs[name] } else { var id = DNS.address_map.id++; assert(id < 65535, "exceeded max address mappings of 65535"); addr = "172.29." + (id & 255) + "." + (id & 65280); DNS.address_map.names[addr] = name; DNS.address_map.addrs[name] = addr } return addr }, lookup_addr(addr) { if (DNS.address_map.names[addr]) { return DNS.address_map.names[addr] } return null } }; var getSocketAddress = (addrp, addrlen, allowNull) => { if (allowNull && addrp === 0) return null; var info = readSockaddr(addrp, addrlen); if (info.errno) throw new FS.ErrnoError(info.errno); info.addr = DNS.lookup_addr(info.addr) || info.addr; return info }; function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) { try { var sock = getSocketFromFD(fd); var info = getSocketAddress(addr, addrlen); sock.sock_ops.connect(sock, info.addr, info.port); return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(dirfd, path, allowEmpty) { if (PATH.isAbs(path)) { return path } var dir; if (dirfd === -100) { dir = FS.cwd() } else { var dirstream = SYSCALLS.getStreamFromFD(dirfd); dir = dirstream.path } if (path.length == 0) { if (!allowEmpty) { throw new FS.ErrnoError(44) } return dir } return PATH.join2(dir, path) }, doStat(func, path, buf) { var stat = func(path); HEAP32[buf >> 2] = stat.dev; HEAP32[buf + 4 >> 2] = stat.mode; HEAPU32[buf + 8 >> 2] = stat.nlink; HEAP32[buf + 12 >> 2] = stat.uid; HEAP32[buf + 16 >> 2] = stat.gid; HEAP32[buf + 20 >> 2] = stat.rdev; tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1]; HEAP32[buf + 32 >> 2] = 4096; HEAP32[buf + 36 >> 2] = stat.blocks; var atime = stat.atime.getTime(); var mtime = stat.mtime.getTime(); var ctime = stat.ctime.getTime(); tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1]; HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3; tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1]; HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3; tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1]; HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3; tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1]; return 0 }, doMsync(addr, stream, len, flags, offset) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } if (flags & 2) { return 0 } var buffer = HEAPU8.slice(addr, addr + len); FS.msync(stream, buffer, offset, len, flags) }, getStreamFromFD(fd) { var stream = FS.getStreamChecked(fd); return stream }, varargs: undefined, getStr(ptr) { var ret = UTF8ToString(ptr); return ret } }; function ___syscall_faccessat(dirfd, path, amode, flags) { try { path = SYSCALLS.getStr(path); assert(flags === 0); path = SYSCALLS.calculateAt(dirfd, path); if (amode & ~7) { return -28 } var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; if (!node) { return -44 } var perms = ""; if (amode & 4) perms += "r"; if (amode & 2) perms += "w"; if (amode & 1) perms += "x"; if (perms && FS.nodePermissions(node, perms)) { return -2 } return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function syscallGetVarargI() { assert(SYSCALLS.varargs != undefined); var ret = HEAP32[+SYSCALLS.varargs >> 2]; SYSCALLS.varargs += 4; return ret } var syscallGetVarargP = syscallGetVarargI; function ___syscall_fcntl64(fd, cmd, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(fd); switch (cmd) { case 0: { var arg = syscallGetVarargI(); if (arg < 0) { return -28 } while (FS.streams[arg]) { arg++ } var newStream; newStream = FS.dupStream(stream, arg); return newStream.fd } case 1: case 2: return 0; case 3: return stream.flags; case 4: { var arg = syscallGetVarargI(); stream.flags |= arg; return 0 } case 12: { var arg = syscallGetVarargP(); var offset = 0; HEAP16[arg + offset >> 1] = 2; return 0 } case 13: case 14: return 0 }return -28 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_fstat64(fd, buf) { try { var stream = SYSCALLS.getStreamFromFD(fd); return SYSCALLS.doStat(FS.stat, stream.path, buf) } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_ioctl(fd, op, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(fd); switch (op) { case 21509: { if (!stream.tty) return -59; return 0 } case 21505: { if (!stream.tty) return -59; if (stream.tty.ops.ioctl_tcgets) { var termios = stream.tty.ops.ioctl_tcgets(stream); var argp = syscallGetVarargP(); HEAP32[argp >> 2] = termios.c_iflag || 0; HEAP32[argp + 4 >> 2] = termios.c_oflag || 0; HEAP32[argp + 8 >> 2] = termios.c_cflag || 0; HEAP32[argp + 12 >> 2] = termios.c_lflag || 0; for (var i = 0; i < 32; i++) { HEAP8[argp + i + 17] = termios.c_cc[i] || 0 } return 0 } return 0 } case 21510: case 21511: case 21512: { if (!stream.tty) return -59; return 0 } case 21506: case 21507: case 21508: { if (!stream.tty) return -59; if (stream.tty.ops.ioctl_tcsets) { var argp = syscallGetVarargP(); var c_iflag = HEAP32[argp >> 2]; var c_oflag = HEAP32[argp + 4 >> 2]; var c_cflag = HEAP32[argp + 8 >> 2]; var c_lflag = HEAP32[argp + 12 >> 2]; var c_cc = []; for (var i = 0; i < 32; i++) { c_cc.push(HEAP8[argp + i + 17]) } return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag: c_iflag, c_oflag: c_oflag, c_cflag: c_cflag, c_lflag: c_lflag, c_cc: c_cc }) } return 0 } case 21519: { if (!stream.tty) return -59; var argp = syscallGetVarargP(); HEAP32[argp >> 2] = 0; return 0 } case 21520: { if (!stream.tty) return -59; return -28 } case 21531: { var argp = syscallGetVarargP(); return FS.ioctl(stream, op, argp) } case 21523: { if (!stream.tty) return -59; if (stream.tty.ops.ioctl_tiocgwinsz) { var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty); var argp = syscallGetVarargP(); HEAP16[argp >> 1] = winsize[0]; HEAP16[argp + 2 >> 1] = winsize[1] } return 0 } case 21524: { if (!stream.tty) return -59; return 0 } case 21515: { if (!stream.tty) return -59; return 0 } default: return -28 } } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_lstat64(path, buf) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doStat(FS.lstat, path, buf) } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_newfstatat(dirfd, path, buf, flags) { try { path = SYSCALLS.getStr(path); var nofollow = flags & 256; var allowEmpty = flags & 4096; flags = flags & ~6400; assert(!flags, `unknown flags in __syscall_newfstatat: ${flags}`); path = SYSCALLS.calculateAt(dirfd, path, allowEmpty); return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf) } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_openat(dirfd, path, flags, varargs) { SYSCALLS.varargs = varargs; try { path = SYSCALLS.getStr(path); path = SYSCALLS.calculateAt(dirfd, path); var mode = varargs ? syscallGetVarargI() : 0; return FS.open(path, flags, mode).fd } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) { try { oldpath = SYSCALLS.getStr(oldpath); newpath = SYSCALLS.getStr(newpath); oldpath = SYSCALLS.calculateAt(olddirfd, oldpath); newpath = SYSCALLS.calculateAt(newdirfd, newpath); FS.rename(oldpath, newpath); return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_rmdir(path) { try { path = SYSCALLS.getStr(path); FS.rmdir(path); return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_sendto(fd, message, length, flags, addr, addr_len) { try { var sock = getSocketFromFD(fd); var dest = getSocketAddress(addr, addr_len, true); if (!dest) { return FS.write(sock.stream, HEAP8, message, length) } return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port) } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_socket(domain, type, protocol) { try { var sock = SOCKFS.createSocket(domain, type, protocol); assert(sock.stream.fd < 64); return sock.stream.fd } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_stat64(path, buf) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doStat(FS.stat, path, buf) } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } function ___syscall_unlinkat(dirfd, path, flags) { try { path = SYSCALLS.getStr(path); path = SYSCALLS.calculateAt(dirfd, path); if (flags === 0) { FS.unlink(path) } else if (flags === 512) { FS.rmdir(path) } else { abort("Invalid flags passed to unlinkat") } return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return -e.errno } } var __abort_js = () => { abort("native code called abort()") }; function __emscripten_fetch_free(id) { if (Fetch.xhrs.has(id)) { var xhr = Fetch.xhrs.get(id); Fetch.xhrs.free(id); if (xhr.readyState > 0 && xhr.readyState < 4) { xhr.abort() } } } var stringToUTF8 = (str, outPtr, maxBytesToWrite) => { assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"); return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) }; function __emscripten_fetch_get_response_headers(id, dst, dstSizeBytes) { var responseHeaders = Fetch.xhrs.get(id).getAllResponseHeaders(); var lengthBytes = lengthBytesUTF8(responseHeaders) + 1; stringToUTF8(responseHeaders, dst, dstSizeBytes); return Math.min(lengthBytes, dstSizeBytes) } function __emscripten_fetch_get_response_headers_length(id) { return lengthBytesUTF8(Fetch.xhrs.get(id).getAllResponseHeaders()) + 1 } var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num); var __emscripten_throw_longjmp = () => { throw new EmscriptenSjLj }; var convertI32PairToI53Checked = (lo, hi) => { assert(lo == lo >>> 0 || lo == (lo | 0)); assert(hi === (hi | 0)); return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN }; function __gmtime_js(time_low, time_high, tmPtr) { var time = convertI32PairToI53Checked(time_low, time_high); var date = new Date(time * 1e3); HEAP32[tmPtr >> 2] = date.getUTCSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getUTCHours(); HEAP32[tmPtr + 12 >> 2] = date.getUTCDate(); HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth(); HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getUTCDay(); var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0); var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0; HEAP32[tmPtr + 28 >> 2] = yday } var isLeapYear = year => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0); var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]; var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]; var ydayFromDate = date => { var leap = isLeapYear(date.getFullYear()); var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE; var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; return yday }; function __localtime_js(time_low, time_high, tmPtr) { var time = convertI32PairToI53Checked(time_low, time_high); var date = new Date(time * 1e3); HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900; HEAP32[tmPtr + 24 >> 2] = date.getDay(); var yday = ydayFromDate(date) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60); var start = new Date(date.getFullYear(), 0, 1); var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); var winterOffset = start.getTimezoneOffset(); var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0; HEAP32[tmPtr + 32 >> 2] = dst } var __mktime_js = function (tmPtr) { var ret = (() => { var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0); var dst = HEAP32[tmPtr + 32 >> 2]; var guessedOffset = date.getTimezoneOffset(); var start = new Date(date.getFullYear(), 0, 1); var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset(); var winterOffset = start.getTimezoneOffset(); var dstOffset = Math.min(winterOffset, summerOffset); if (dst < 0) { HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset) } else if (dst > 0 != (dstOffset == guessedOffset)) { var nonDstOffset = Math.max(winterOffset, summerOffset); var trueOffset = dst > 0 ? dstOffset : nonDstOffset; date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4) } HEAP32[tmPtr + 24 >> 2] = date.getDay(); var yday = ydayFromDate(date) | 0; HEAP32[tmPtr + 28 >> 2] = yday; HEAP32[tmPtr >> 2] = date.getSeconds(); HEAP32[tmPtr + 4 >> 2] = date.getMinutes(); HEAP32[tmPtr + 8 >> 2] = date.getHours(); HEAP32[tmPtr + 12 >> 2] = date.getDate(); HEAP32[tmPtr + 16 >> 2] = date.getMonth(); HEAP32[tmPtr + 20 >> 2] = date.getYear(); var timeMs = date.getTime(); if (isNaN(timeMs)) { return -1 } return timeMs / 1e3 })(); return setTempRet0((tempDouble = ret, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)), ret >>> 0 }; var __tzset_js = (timezone, daylight, std_name, dst_name) => { var currentYear = (new Date).getFullYear(); var winter = new Date(currentYear, 0, 1); var summer = new Date(currentYear, 6, 1); var winterOffset = winter.getTimezoneOffset(); var summerOffset = summer.getTimezoneOffset(); var stdTimezoneOffset = Math.max(winterOffset, summerOffset); HEAPU32[timezone >> 2] = stdTimezoneOffset * 60; HEAP32[daylight >> 2] = Number(winterOffset != summerOffset); var extractZone = date => date.toLocaleTimeString(undefined, { hour12: false, timeZoneName: "short" }).split(" ")[1]; var winterName = extractZone(winter); var summerName = extractZone(summer); assert(winterName); assert(summerName); assert(lengthBytesUTF8(winterName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${winterName})`); assert(lengthBytesUTF8(summerName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${summerName})`); if (summerOffset < winterOffset) { stringToUTF8(winterName, std_name, 17); stringToUTF8(summerName, dst_name, 17) } else { stringToUTF8(winterName, dst_name, 17); stringToUTF8(summerName, std_name, 17) } }; var readEmAsmArgsArray = []; var readEmAsmArgs = (sigPtr, buf) => { assert(Array.isArray(readEmAsmArgsArray)); assert(buf % 16 == 0); readEmAsmArgsArray.length = 0; var ch; while (ch = HEAPU8[sigPtr++]) { var chr = String.fromCharCode(ch); var validChars = ["d", "f", "i", "p"]; assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`); var wide = ch != 105; wide &= ch != 112; buf += wide && buf % 8 ? 4 : 0; readEmAsmArgsArray.push(ch == 112 ? HEAPU32[buf >> 2] : ch == 105 ? HEAP32[buf >> 2] : HEAPF64[buf >> 3]); buf += wide ? 8 : 4 } return readEmAsmArgsArray }; var runEmAsmFunction = (code, sigPtr, argbuf) => { var args = readEmAsmArgs(sigPtr, argbuf); assert(ASM_CONSTS.hasOwnProperty(code), `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`); return ASM_CONSTS[code](...args) }; var _emscripten_asm_const_int = (code, sigPtr, argbuf) => runEmAsmFunction(code, sigPtr, argbuf); var _emscripten_console_error = str => { assert(typeof str == "number"); console.error(UTF8ToString(str)) }; var _emscripten_console_log = str => { assert(typeof str == "number"); console.log(UTF8ToString(str)) }; var _emscripten_console_warn = str => { assert(typeof str == "number"); console.warn(UTF8ToString(str)) }; var _emscripten_date_now = () => Date.now(); var _emscripten_err = str => err(UTF8ToString(str)); var JSEvents = { removeAllEventListeners() { while (JSEvents.eventHandlers.length) { JSEvents._removeHandler(JSEvents.eventHandlers.length - 1) } JSEvents.deferredCalls = [] }, inEventHandler: 0, deferredCalls: [], deferCall(targetFunction, precedence, argsList) { function arraysHaveEqualContent(arrA, arrB) { if (arrA.length != arrB.length) return false; for (var i in arrA) { if (arrA[i] != arrB[i]) return false } return true } for (var i in JSEvents.deferredCalls) { var call = JSEvents.deferredCalls[i]; if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) { return } } JSEvents.deferredCalls.push({ targetFunction: targetFunction, precedence: precedence, argsList: argsList }); JSEvents.deferredCalls.sort((x, y) => x.precedence < y.precedence) }, removeDeferredCalls(targetFunction) { for (var i = 0; i < JSEvents.deferredCalls.length; ++i) { if (JSEvents.deferredCalls[i].targetFunction == targetFunction) { JSEvents.deferredCalls.splice(i, 1); --i } } }, canPerformEventHandlerRequests() { if (navigator.userActivation) { return navigator.userActivation.isActive } return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls }, runDeferredCalls() { if (!JSEvents.canPerformEventHandlerRequests()) { return } for (var i = 0; i < JSEvents.deferredCalls.length; ++i) { var call = JSEvents.deferredCalls[i]; JSEvents.deferredCalls.splice(i, 1); --i; call.targetFunction(...call.argsList) } }, eventHandlers: [], removeAllHandlersOnTarget: (target, eventTypeString) => { for (var i = 0; i < JSEvents.eventHandlers.length; ++i) { if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) { JSEvents._removeHandler(i--) } } }, _removeHandler(i) { var h = JSEvents.eventHandlers[i]; h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture); JSEvents.eventHandlers.splice(i, 1) }, registerOrRemoveHandler(eventHandler) { if (!eventHandler.target) { err("registerOrRemoveHandler: the target element for event handler registration does not exist, when processing the following event handler registration:"); console.dir(eventHandler); return -4 } if (eventHandler.callbackfunc) { eventHandler.eventListenerFunc = function (event) { ++JSEvents.inEventHandler; JSEvents.currentEventHandler = eventHandler; JSEvents.runDeferredCalls(); eventHandler.handlerFunc(event); JSEvents.runDeferredCalls(); --JSEvents.inEventHandler }; eventHandler.target.addEventListener(eventHandler.eventTypeString, eventHandler.eventListenerFunc, eventHandler.useCapture); JSEvents.eventHandlers.push(eventHandler) } else { for (var i = 0; i < JSEvents.eventHandlers.length; ++i) { if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) { JSEvents._removeHandler(i--) } } } return 0 }, getNodeNameForTarget(target) { if (!target) return ""; if (target == window) return "#window"; if (target == screen) return "#screen"; return target?.nodeName || "" }, fullscreenEnabled() { return document.fullscreenEnabled || document.webkitFullscreenEnabled } }; var maybeCStringToJsString = cString => cString > 2 ? UTF8ToString(cString) : cString; var specialHTMLTargets = [0, document, window]; var findEventTarget = target => { target = maybeCStringToJsString(target); var domElement = specialHTMLTargets[target] || document.querySelector(target); return domElement }; var getBoundingClientRect = e => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : { "left": 0, "top": 0 }; var _emscripten_get_element_css_size = (target, width, height) => { target = findEventTarget(target); if (!target) return -4; var rect = getBoundingClientRect(target); HEAPF64[width >> 3] = rect.width; HEAPF64[height >> 3] = rect.height; return 0 }; var handleException = e => { if (e instanceof ExitStatus || e == "unwind") { return EXITSTATUS } checkStackCookie(); if (e instanceof WebAssembly.RuntimeError) { if (_emscripten_stack_get_current() <= 0) { err("Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)") } } quit_(1, e) }; var runtimeKeepaliveCounter = 0; var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0; var _proc_exit = code => { EXITSTATUS = code; if (!keepRuntimeAlive()) { Module["onExit"]?.(code); ABORT = true } quit_(code, new ExitStatus(code)) }; var exitJS = (status, implicit) => { EXITSTATUS = status; checkUnflushedContent(); if (keepRuntimeAlive() && !implicit) { var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`; readyPromiseReject(msg); err(msg) } _proc_exit(status) }; var _exit = exitJS; var maybeExit = () => { if (!keepRuntimeAlive()) { try { _exit(EXITSTATUS) } catch (e) { handleException(e) } } }; var callUserCallback = func => { if (ABORT) { err("user callback triggered after runtime exited or application aborted.  Ignoring."); return } try { func(); maybeExit() } catch (e) { handleException(e) } }; var IDBStore = { indexedDB() { if (typeof indexedDB != "undefined") return indexedDB; var ret = null; if (typeof window == "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; assert(ret, "IDBStore used, but indexedDB not supported"); return ret }, DB_VERSION: 22, DB_STORE_NAME: "FILE_DATA", dbs: {}, blobs: [0], getDB(name, callback) { var db = IDBStore.dbs[name]; if (db) { return callback(null, db) } var req; try { req = IDBStore.indexedDB().open(name, IDBStore.DB_VERSION) } catch (e) { return callback(e) } req.onupgradeneeded = e => { var db = e.target.result; var transaction = e.target.transaction; var fileStore; if (db.objectStoreNames.contains(IDBStore.DB_STORE_NAME)) { fileStore = transaction.objectStore(IDBStore.DB_STORE_NAME) } else { fileStore = db.createObjectStore(IDBStore.DB_STORE_NAME) } }; req.onsuccess = () => { db = req.result; IDBStore.dbs[name] = db; callback(null, db) }; req.onerror = function (event) { callback(event.target.error || "unknown error"); event.preventDefault() } }, getStore(dbName, type, callback) { IDBStore.getDB(dbName, (error, db) => { if (error) return callback(error); var transaction = db.transaction([IDBStore.DB_STORE_NAME], type); transaction.onerror = event => { callback(event.target.error || "unknown error"); event.preventDefault() }; var store = transaction.objectStore(IDBStore.DB_STORE_NAME); callback(null, store) }) }, getFile(dbName, id, callback) { IDBStore.getStore(dbName, "readonly", (err, store) => { if (err) return callback(err); var req = store.get(id); req.onsuccess = event => { var result = event.target.result; if (!result) { return callback(`file ${id} not found`) } return callback(null, result) }; req.onerror = callback }) }, setFile(dbName, id, data, callback) { IDBStore.getStore(dbName, "readwrite", (err, store) => { if (err) return callback(err); var req = store.put(data, id); req.onsuccess = event => callback(); req.onerror = callback }) }, deleteFile(dbName, id, callback) { IDBStore.getStore(dbName, "readwrite", (err, store) => { if (err) return callback(err); var req = store.delete(id); req.onsuccess = event => callback(); req.onerror = callback }) }, existsFile(dbName, id, callback) { IDBStore.getStore(dbName, "readonly", (err, store) => { if (err) return callback(err); var req = store.count(id); req.onsuccess = event => callback(null, event.target.result > 0); req.onerror = callback }) }, clearStore(dbName, callback) { IDBStore.getStore(dbName, "readwrite", (err, store) => { if (err) return callback(err); var req = store.clear(); req.onsuccess = event => callback(); req.onerror = callback }) } }; var wasmTableMirror = []; var wasmTable; var getWasmTableEntry = funcPtr => { var func = wasmTableMirror[funcPtr]; if (!func) { if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1; wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr) } assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!"); return func }; var _emscripten_idb_async_load = (db, id, arg, onload, onerror) => { IDBStore.getFile(UTF8ToString(db), UTF8ToString(id), (error, byteArray) => { callUserCallback(() => { if (error) { if (onerror) getWasmTableEntry(onerror)(arg); return } var buffer = _malloc(byteArray.length); HEAPU8.set(byteArray, buffer); getWasmTableEntry(onload)(arg, buffer, byteArray.length); _free(buffer) }) }) }; var _emscripten_is_main_browser_thread = () => !ENVIRONMENT_IS_WORKER; var webgl_enable_ANGLE_instanced_arrays = ctx => { var ext = ctx.getExtension("ANGLE_instanced_arrays"); if (ext) { ctx["vertexAttribDivisor"] = (index, divisor) => ext["vertexAttribDivisorANGLE"](index, divisor); ctx["drawArraysInstanced"] = (mode, first, count, primcount) => ext["drawArraysInstancedANGLE"](mode, first, count, primcount); ctx["drawElementsInstanced"] = (mode, count, type, indices, primcount) => ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount); return 1 } }; var webgl_enable_OES_vertex_array_object = ctx => { var ext = ctx.getExtension("OES_vertex_array_object"); if (ext) { ctx["createVertexArray"] = () => ext["createVertexArrayOES"](); ctx["deleteVertexArray"] = vao => ext["deleteVertexArrayOES"](vao); ctx["bindVertexArray"] = vao => ext["bindVertexArrayOES"](vao); ctx["isVertexArray"] = vao => ext["isVertexArrayOES"](vao); return 1 } }; var webgl_enable_WEBGL_draw_buffers = ctx => { var ext = ctx.getExtension("WEBGL_draw_buffers"); if (ext) { ctx["drawBuffers"] = (n, bufs) => ext["drawBuffersWEBGL"](n, bufs); return 1 } }; var webgl_enable_WEBGL_multi_draw = ctx => !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw")); var getEmscriptenSupportedExtensions = ctx => { var supportedExtensions = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_disjoint_timer_query", "EXT_frag_depth", "EXT_shader_texture_lod", "EXT_sRGB", "OES_element_index_uint", "OES_fbo_render_mipmap", "OES_standard_derivatives", "OES_texture_float", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_depth_texture", "WEBGL_draw_buffers", "EXT_color_buffer_half_float", "EXT_depth_clamp", "EXT_float_blend", "EXT_texture_compression_bptc", "EXT_texture_compression_rgtc", "EXT_texture_filter_anisotropic", "KHR_parallel_shader_compile", "OES_texture_float_linear", "WEBGL_blend_func_extended", "WEBGL_compressed_texture_astc", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_debug_renderer_info", "WEBGL_debug_shaders", "WEBGL_lose_context", "WEBGL_multi_draw"]; return (ctx.getSupportedExtensions() || []).filter(ext => supportedExtensions.includes(ext)) }; var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: [], offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: errorCode => { if (!GL.lastError) { GL.lastError = errorCode } }, getNewId: table => { var ret = GL.counter++; for (var i = table.length; i < ret; i++) { table[i] = null } return ret }, genObject: (n, buffers, createFunction, objectTable) => { for (var i = 0; i < n; i++) { var buffer = GLctx[createFunction](); var id = buffer && GL.getNewId(objectTable); if (buffer) { buffer.name = id; objectTable[id] = buffer } else { GL.recordError(1282) } HEAP32[buffers + i * 4 >> 2] = id } }, getSource: (shader, count, string, length) => { var source = ""; for (var i = 0; i < count; ++i) { var len = length ? HEAPU32[length + i * 4 >> 2] : undefined; source += UTF8ToString(HEAPU32[string + i * 4 >> 2], len) } return source }, createContext: (canvas, webGLContextAttributes) => { if (!canvas.getContextSafariWebGL2Fixed) { canvas.getContextSafariWebGL2Fixed = canvas.getContext; function fixedGetContext(ver, attrs) { var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs); return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null } canvas.getContext = fixedGetContext } var ctx = canvas.getContext("webgl", webGLContextAttributes); if (!ctx) return 0; var handle = GL.registerContext(ctx, webGLContextAttributes); return handle }, registerContext: (ctx, webGLContextAttributes) => { var handle = GL.getNewId(GL.contexts); var context = { handle: handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx }; if (ctx.canvas) ctx.canvas.GLctxObject = context; GL.contexts[handle] = context; if (typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" || webGLContextAttributes.enableExtensionsByDefault) { GL.initExtensions(context) } return handle }, makeContextCurrent: contextHandle => { GL.currentContext = GL.contexts[contextHandle]; Module.ctx = GLctx = GL.currentContext?.GLctx; return !(contextHandle && !GLctx) }, getContext: contextHandle => GL.contexts[contextHandle], deleteContext: contextHandle => { if (GL.currentContext === GL.contexts[contextHandle]) { GL.currentContext = null } if (typeof JSEvents == "object") { JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas) } if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) { GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined } GL.contexts[contextHandle] = null }, initExtensions: context => { context ||= GL.currentContext; if (context.initExtensionsDone) return; context.initExtensionsDone = true; var GLctx = context.GLctx; webgl_enable_ANGLE_instanced_arrays(GLctx); webgl_enable_OES_vertex_array_object(GLctx); webgl_enable_WEBGL_draw_buffers(GLctx); { GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query") } webgl_enable_WEBGL_multi_draw(GLctx); getEmscriptenSupportedExtensions(GLctx).forEach(ext => { if (!ext.includes("lose_context") && !ext.includes("debug")) { GLctx.getExtension(ext) } }) } }; var _emscripten_is_webgl_context_lost = contextHandle => !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost(); var _emscripten_request_animation_frame = (cb, userData) => requestAnimationFrame(timeStamp => getWasmTableEntry(cb)(timeStamp, userData)); var getHeapMax = () => 2147483648; var growMemory = size => { var b = wasmMemory.buffer; var pages = (size - b.byteLength + 65535) / 65536; try { wasmMemory.grow(pages); updateMemoryViews(); return 1 } catch (e) { err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`) } }; var _emscripten_resize_heap = requestedSize => { var oldSize = HEAPU8.length; requestedSize >>>= 0; assert(requestedSize > oldSize); var maxHeapSize = getHeapMax(); if (requestedSize > maxHeapSize) { err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`); return false } var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple; for (var cutDown = 1; cutDown <= 4; cutDown *= 2) { var overGrownHeapSize = oldSize * (1 + .2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)); var replacement = growMemory(newSize); if (replacement) { return true } } err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`); return false }; var findCanvasEventTarget = findEventTarget; var _emscripten_set_canvas_element_size = (target, width, height) => { var canvas = findCanvasEventTarget(target); if (!canvas) return -4; canvas.width = width; canvas.height = height; return 0 }; var fillMouseEventData = (eventStruct, e, target) => { assert(eventStruct % 4 == 0); HEAPF64[eventStruct >> 3] = e.timeStamp; var idx = eventStruct >> 2; HEAP32[idx + 2] = e.screenX; HEAP32[idx + 3] = e.screenY; HEAP32[idx + 4] = e.clientX; HEAP32[idx + 5] = e.clientY; HEAP32[idx + 6] = e.ctrlKey; HEAP32[idx + 7] = e.shiftKey; HEAP32[idx + 8] = e.altKey; HEAP32[idx + 9] = e.metaKey; HEAP16[idx * 2 + 20] = e.button; HEAP16[idx * 2 + 21] = e.buttons; HEAP32[idx + 11] = e["movementX"]; HEAP32[idx + 12] = e["movementY"]; var rect = getBoundingClientRect(target); HEAP32[idx + 13] = e.clientX - (rect.left | 0); HEAP32[idx + 14] = e.clientY - (rect.top | 0) }; var registerMouseEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => { if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc(72); target = findEventTarget(target); var mouseEventHandlerFunc = (e = event) => { fillMouseEventData(JSEvents.mouseEvent, e, target); if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault() }; var eventHandler = { target: target, allowsDeferredCalls: eventTypeString != "mousemove" && eventTypeString != "mouseenter" && eventTypeString != "mouseleave", eventTypeString: eventTypeString, callbackfunc: callbackfunc, handlerFunc: mouseEventHandlerFunc, useCapture: useCapture }; return JSEvents.registerOrRemoveHandler(eventHandler) }; var _emscripten_set_mousedown_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread); var _emscripten_set_mousemove_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread); var _emscripten_set_mouseup_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread); var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => { if (!JSEvents.uiEvent) JSEvents.uiEvent = _malloc(36); target = findEventTarget(target); var uiEventHandlerFunc = (e = event) => { if (e.target != target) { return } var b = document.body; if (!b) { return } var uiEvent = JSEvents.uiEvent; HEAP32[uiEvent >> 2] = 0; HEAP32[uiEvent + 4 >> 2] = b.clientWidth; HEAP32[uiEvent + 8 >> 2] = b.clientHeight; HEAP32[uiEvent + 12 >> 2] = innerWidth; HEAP32[uiEvent + 16 >> 2] = innerHeight; HEAP32[uiEvent + 20 >> 2] = outerWidth; HEAP32[uiEvent + 24 >> 2] = outerHeight; HEAP32[uiEvent + 28 >> 2] = pageXOffset | 0; HEAP32[uiEvent + 32 >> 2] = pageYOffset | 0; if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData)) e.preventDefault() }; var eventHandler = { target: target, eventTypeString: eventTypeString, callbackfunc: callbackfunc, handlerFunc: uiEventHandlerFunc, useCapture: useCapture }; return JSEvents.registerOrRemoveHandler(eventHandler) }; var _emscripten_set_resize_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread); var safeSetTimeout = (func, timeout) => setTimeout(() => { callUserCallback(func) }, timeout); var _emscripten_set_timeout = (cb, msecs, userData) => safeSetTimeout(() => getWasmTableEntry(cb)(userData), msecs); var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => { if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc(104); var wheelHandlerFunc = (e = event) => { var wheelEvent = JSEvents.wheelEvent; fillMouseEventData(wheelEvent, e, target); HEAPF64[wheelEvent + 72 >> 3] = e["deltaX"]; HEAPF64[wheelEvent + 80 >> 3] = e["deltaY"]; HEAPF64[wheelEvent + 88 >> 3] = e["deltaZ"]; HEAP32[wheelEvent + 96 >> 2] = e["deltaMode"]; if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData)) e.preventDefault() }; var eventHandler = { target: target, allowsDeferredCalls: true, eventTypeString: eventTypeString, callbackfunc: callbackfunc, handlerFunc: wheelHandlerFunc, useCapture: useCapture }; return JSEvents.registerOrRemoveHandler(eventHandler) }; var _emscripten_set_wheel_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => { target = findEventTarget(target); if (!target) return -4; if (typeof target.onwheel != "undefined") { return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread) } else { return -1 } }; class HandleAllocator { constructor() { this.allocated = [undefined]; this.freelist = [] } get(id) { assert(this.allocated[id] !== undefined, `invalid handle: ${id}`); return this.allocated[id] } has(id) { return this.allocated[id] !== undefined } allocate(handle) { var id = this.freelist.pop() || this.allocated.length; this.allocated[id] = handle; return id } free(id) { assert(this.allocated[id] !== undefined); this.allocated[id] = undefined; this.freelist.push(id) } } var Fetch = { openDatabase(dbname, dbversion, onsuccess, onerror) { try { var openRequest = indexedDB.open(dbname, dbversion) } catch (e) { return onerror(e) } openRequest.onupgradeneeded = event => { var db = event.target.result; if (db.objectStoreNames.contains("FILES")) { db.deleteObjectStore("FILES") } db.createObjectStore("FILES") }; openRequest.onsuccess = event => onsuccess(event.target.result); openRequest.onerror = onerror }, init() { Fetch.xhrs = new HandleAllocator; var onsuccess = db => { Fetch.dbInstance = db; removeRunDependency("library_fetch_init") }; var onerror = () => { Fetch.dbInstance = false; removeRunDependency("library_fetch_init") }; addRunDependency("library_fetch_init"); Fetch.openDatabase("emscripten_filesystem", 1, onsuccess, onerror) } }; function fetchXHR(fetch, onsuccess, onerror, onprogress, onreadystatechange) { var url = HEAPU32[fetch + 8 >> 2]; if (!url) { onerror(fetch, 0, "no url specified!"); return } var url_ = UTF8ToString(url); var fetch_attr = fetch + 112; var requestMethod = UTF8ToString(fetch_attr + 0); requestMethod ||= "GET"; var timeoutMsecs = HEAPU32[fetch_attr + 56 >> 2]; var userName = HEAPU32[fetch_attr + 68 >> 2]; var password = HEAPU32[fetch_attr + 72 >> 2]; var requestHeaders = HEAPU32[fetch_attr + 76 >> 2]; var overriddenMimeType = HEAPU32[fetch_attr + 80 >> 2]; var dataPtr = HEAPU32[fetch_attr + 84 >> 2]; var dataLength = HEAPU32[fetch_attr + 88 >> 2]; var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2]; var fetchAttrLoadToMemory = !!(fetchAttributes & 1); var fetchAttrStreamData = !!(fetchAttributes & 2); var fetchAttrSynchronous = !!(fetchAttributes & 64); var userNameStr = userName ? UTF8ToString(userName) : undefined; var passwordStr = password ? UTF8ToString(password) : undefined; var xhr = new XMLHttpRequest; xhr.withCredentials = !!HEAPU8[fetch_attr + 60]; xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr); if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; xhr.url_ = url_; assert(!fetchAttrStreamData, "streaming uses moz-chunked-arraybuffer which is no longer supported; TODO: rewrite using fetch()"); xhr.responseType = "arraybuffer"; if (overriddenMimeType) { var overriddenMimeTypeStr = UTF8ToString(overriddenMimeType); xhr.overrideMimeType(overriddenMimeTypeStr) } if (requestHeaders) { for (; ;) { var key = HEAPU32[requestHeaders >> 2]; if (!key) break; var value = HEAPU32[requestHeaders + 4 >> 2]; if (!value) break; requestHeaders += 8; var keyStr = UTF8ToString(key); var valueStr = UTF8ToString(value); xhr.setRequestHeader(keyStr, valueStr) } } var id = Fetch.xhrs.allocate(xhr); HEAPU32[fetch >> 2] = id; var data = dataPtr && dataLength ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null; function saveResponseAndStatus() { var ptr = 0; var ptrLen = 0; if (xhr.response && fetchAttrLoadToMemory && HEAPU32[fetch + 12 >> 2] === 0) { ptrLen = xhr.response.byteLength } if (ptrLen > 0) { ptr = _malloc(ptrLen); HEAPU8.set(new Uint8Array(xhr.response), ptr) } HEAPU32[fetch + 12 >> 2] = ptr; writeI53ToI64(fetch + 16, ptrLen); writeI53ToI64(fetch + 24, 0); var len = xhr.response ? xhr.response.byteLength : 0; if (len) { writeI53ToI64(fetch + 32, len) } HEAP16[fetch + 40 >> 1] = xhr.readyState; HEAP16[fetch + 42 >> 1] = xhr.status; if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64) } xhr.onload = e => { if (!Fetch.xhrs.has(id)) { return } saveResponseAndStatus(); if (xhr.status >= 200 && xhr.status < 300) { onsuccess?.(fetch, xhr, e) } else { onerror?.(fetch, xhr, e) } }; xhr.onerror = e => { if (!Fetch.xhrs.has(id)) { return } saveResponseAndStatus(); onerror?.(fetch, xhr, e) }; xhr.ontimeout = e => { if (!Fetch.xhrs.has(id)) { return } onerror?.(fetch, xhr, e) }; xhr.onprogress = e => { if (!Fetch.xhrs.has(id)) { return } var ptrLen = fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response ? xhr.response.byteLength : 0; var ptr = 0; if (ptrLen > 0 && fetchAttrLoadToMemory && fetchAttrStreamData) { assert(onprogress, "When doing a streaming fetch, you should have an onprogress handler registered to receive the chunks!"); ptr = _malloc(ptrLen); HEAPU8.set(new Uint8Array(xhr.response), ptr) } HEAPU32[fetch + 12 >> 2] = ptr; writeI53ToI64(fetch + 16, ptrLen); writeI53ToI64(fetch + 24, e.loaded - ptrLen); writeI53ToI64(fetch + 32, e.total); HEAP16[fetch + 40 >> 1] = xhr.readyState; if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; HEAP16[fetch + 42 >> 1] = xhr.status; if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64); onprogress?.(fetch, xhr, e); if (ptr) { _free(ptr) } }; xhr.onreadystatechange = e => { if (!Fetch.xhrs.has(id)) { return } HEAP16[fetch + 40 >> 1] = xhr.readyState; if (xhr.readyState >= 2) { HEAP16[fetch + 42 >> 1] = xhr.status } onreadystatechange?.(fetch, xhr, e) }; try { xhr.send(data) } catch (e) { onerror?.(fetch, xhr, e) } } var readI53FromI64 = ptr => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296; var readI53FromU64 = ptr => HEAPU32[ptr >> 2] + HEAPU32[ptr + 4 >> 2] * 4294967296; var writeI53ToI64 = (ptr, num) => { HEAPU32[ptr >> 2] = num; var lower = HEAPU32[ptr >> 2]; HEAPU32[ptr + 4 >> 2] = (num - lower) / 4294967296; var deserialized = num >= 0 ? readI53FromU64(ptr) : readI53FromI64(ptr); var offset = ptr >> 2; if (deserialized != num) warnOnce(`writeI53ToI64() out of range: serialized JS Number ${num} to Wasm heap as bytes lo=${ptrToString(HEAPU32[offset])}, hi=${ptrToString(HEAPU32[offset + 1])}, which deserializes back to ${deserialized} instead!`) }; function fetchCacheData(db, fetch, data, onsuccess, onerror) { if (!db) { onerror(fetch, 0, "IndexedDB not available!"); return } var fetch_attr = fetch + 112; var destinationPath = HEAPU32[fetch_attr + 64 >> 2]; destinationPath ||= HEAPU32[fetch + 8 >> 2]; var destinationPathStr = UTF8ToString(destinationPath); try { var transaction = db.transaction(["FILES"], "readwrite"); var packages = transaction.objectStore("FILES"); var putRequest = packages.put(data, destinationPathStr); putRequest.onsuccess = event => { HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 200; stringToUTF8("OK", fetch + 44, 64); onsuccess(fetch, 0, destinationPathStr) }; putRequest.onerror = error => { HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 413; stringToUTF8("Payload Too Large", fetch + 44, 64); onerror(fetch, 0, error) } } catch (e) { onerror(fetch, 0, e) } } function fetchLoadCachedData(db, fetch, onsuccess, onerror) { if (!db) { onerror(fetch, 0, "IndexedDB not available!"); return } var fetch_attr = fetch + 112; var path = HEAPU32[fetch_attr + 64 >> 2]; path ||= HEAPU32[fetch + 8 >> 2]; var pathStr = UTF8ToString(path); try { var transaction = db.transaction(["FILES"], "readonly"); var packages = transaction.objectStore("FILES"); var getRequest = packages.get(pathStr); getRequest.onsuccess = event => { if (event.target.result) { var value = event.target.result; var len = value.byteLength || value.length; var ptr = _malloc(len); HEAPU8.set(new Uint8Array(value), ptr); HEAPU32[fetch + 12 >> 2] = ptr; writeI53ToI64(fetch + 16, len); writeI53ToI64(fetch + 24, 0); writeI53ToI64(fetch + 32, len); HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 200; stringToUTF8("OK", fetch + 44, 64); onsuccess(fetch, 0, value) } else { HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 404; stringToUTF8("Not Found", fetch + 44, 64); onerror(fetch, 0, "no data") } }; getRequest.onerror = error => { HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 404; stringToUTF8("Not Found", fetch + 44, 64); onerror(fetch, 0, error) } } catch (e) { onerror(fetch, 0, e) } } function fetchDeleteCachedData(db, fetch, onsuccess, onerror) { if (!db) { onerror(fetch, 0, "IndexedDB not available!"); return } var fetch_attr = fetch + 112; var path = HEAPU32[fetch_attr + 64 >> 2]; path ||= HEAPU32[fetch + 8 >> 2]; var pathStr = UTF8ToString(path); try { var transaction = db.transaction(["FILES"], "readwrite"); var packages = transaction.objectStore("FILES"); var request = packages.delete(pathStr); request.onsuccess = event => { var value = event.target.result; HEAPU32[fetch + 12 >> 2] = 0; writeI53ToI64(fetch + 16, 0); writeI53ToI64(fetch + 24, 0); writeI53ToI64(fetch + 32, 0); HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 200; stringToUTF8("OK", fetch + 44, 64); onsuccess(fetch, 0, value) }; request.onerror = error => { HEAP16[fetch + 40 >> 1] = 4; HEAP16[fetch + 42 >> 1] = 404; stringToUTF8("Not Found", fetch + 44, 64); onerror(fetch, 0, error) } } catch (e) { onerror(fetch, 0, e) } } function _emscripten_start_fetch(fetch, successcb, errorcb, progresscb, readystatechangecb) { var fetch_attr = fetch + 112; var onsuccess = HEAPU32[fetch_attr + 36 >> 2]; var onerror = HEAPU32[fetch_attr + 40 >> 2]; var onprogress = HEAPU32[fetch_attr + 44 >> 2]; var onreadystatechange = HEAPU32[fetch_attr + 48 >> 2]; var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2]; var fetchAttrSynchronous = !!(fetchAttributes & 64); function doCallback(f) { if (fetchAttrSynchronous) { f() } else { callUserCallback(f) } } var reportSuccess = (fetch, xhr, e) => { doCallback(() => { if (onsuccess) getWasmTableEntry(onsuccess)(fetch); else successcb?.(fetch) }) }; var reportProgress = (fetch, xhr, e) => { doCallback(() => { if (onprogress) getWasmTableEntry(onprogress)(fetch); else progresscb?.(fetch) }) }; var reportError = (fetch, xhr, e) => { doCallback(() => { if (onerror) getWasmTableEntry(onerror)(fetch); else errorcb?.(fetch) }) }; var reportReadyStateChange = (fetch, xhr, e) => { doCallback(() => { if (onreadystatechange) getWasmTableEntry(onreadystatechange)(fetch); else readystatechangecb?.(fetch) }) }; var performUncachedXhr = (fetch, xhr, e) => { fetchXHR(fetch, reportSuccess, reportError, reportProgress, reportReadyStateChange) }; var cacheResultAndReportSuccess = (fetch, xhr, e) => { var storeSuccess = (fetch, xhr, e) => { doCallback(() => { if (onsuccess) getWasmTableEntry(onsuccess)(fetch); else successcb?.(fetch) }) }; var storeError = (fetch, xhr, e) => { doCallback(() => { if (onsuccess) getWasmTableEntry(onsuccess)(fetch); else successcb?.(fetch) }) }; fetchCacheData(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError) }; var performCachedXhr = (fetch, xhr, e) => { fetchXHR(fetch, cacheResultAndReportSuccess, reportError, reportProgress, reportReadyStateChange) }; var requestMethod = UTF8ToString(fetch_attr + 0); var fetchAttrReplace = !!(fetchAttributes & 16); var fetchAttrPersistFile = !!(fetchAttributes & 4); var fetchAttrNoDownload = !!(fetchAttributes & 32); if (requestMethod === "EM_IDB_STORE") { var ptr = HEAPU32[fetch_attr + 84 >> 2]; var size = HEAPU32[fetch_attr + 88 >> 2]; fetchCacheData(Fetch.dbInstance, fetch, HEAPU8.slice(ptr, ptr + size), reportSuccess, reportError) } else if (requestMethod === "EM_IDB_DELETE") { fetchDeleteCachedData(Fetch.dbInstance, fetch, reportSuccess, reportError) } else if (!fetchAttrReplace) { fetchLoadCachedData(Fetch.dbInstance, fetch, reportSuccess, fetchAttrNoDownload ? reportError : fetchAttrPersistFile ? performCachedXhr : performUncachedXhr) } else if (!fetchAttrNoDownload) { fetchXHR(fetch, fetchAttrPersistFile ? cacheResultAndReportSuccess : reportSuccess, reportError, reportProgress, reportReadyStateChange) } else { return 0 } return fetch } var webglPowerPreferences = ["default", "low-power", "high-performance"]; var _emscripten_webgl_do_create_context = (target, attributes) => { assert(attributes); var a = attributes >> 2; var powerPreference = HEAP32[a + (24 >> 2)]; var contextAttributes = { "alpha": !!HEAP32[a + (0 >> 2)], "depth": !!HEAP32[a + (4 >> 2)], "stencil": !!HEAP32[a + (8 >> 2)], "antialias": !!HEAP32[a + (12 >> 2)], "premultipliedAlpha": !!HEAP32[a + (16 >> 2)], "preserveDrawingBuffer": !!HEAP32[a + (20 >> 2)], "powerPreference": webglPowerPreferences[powerPreference], "failIfMajorPerformanceCaveat": !!HEAP32[a + (28 >> 2)], majorVersion: HEAP32[a + (32 >> 2)], minorVersion: HEAP32[a + (36 >> 2)], enableExtensionsByDefault: HEAP32[a + (40 >> 2)], explicitSwapControl: HEAP32[a + (44 >> 2)], proxyContextToMainThread: HEAP32[a + (48 >> 2)], renderViaOffscreenBackBuffer: HEAP32[a + (52 >> 2)] }; var canvas = findCanvasEventTarget(target); if (!canvas) { return 0 } if (contextAttributes.explicitSwapControl) { return 0 } var contextHandle = GL.createContext(canvas, contextAttributes); return contextHandle }; var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context; var _emscripten_webgl_destroy_context = contextHandle => { if (GL.currentContext == contextHandle) GL.currentContext = 0; GL.deleteContext(contextHandle) }; var _emscripten_webgl_make_context_current = contextHandle => { var success = GL.makeContextCurrent(contextHandle); return success ? 0 : -5 }; var ENV = {}; var getExecutableName = () => thisProgram || "./this.program"; var getEnvStrings = () => { if (!getEnvStrings.strings) { var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8"; var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() }; for (var x in ENV) { if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x] } var strings = []; for (var x in env) { strings.push(`${x}=${env[x]}`) } getEnvStrings.strings = strings } return getEnvStrings.strings }; var stringToAscii = (str, buffer) => { for (var i = 0; i < str.length; ++i) { assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255)); HEAP8[buffer++] = str.charCodeAt(i) } HEAP8[buffer] = 0 }; var _environ_get = (__environ, environ_buf) => { var bufSize = 0; getEnvStrings().forEach((string, i) => { var ptr = environ_buf + bufSize; HEAPU32[__environ + i * 4 >> 2] = ptr; stringToAscii(string, ptr); bufSize += string.length + 1 }); return 0 }; var _environ_sizes_get = (penviron_count, penviron_buf_size) => { var strings = getEnvStrings(); HEAPU32[penviron_count >> 2] = strings.length; var bufSize = 0; strings.forEach(string => bufSize += string.length + 1); HEAPU32[penviron_buf_size >> 2] = bufSize; return 0 }; function _fd_close(fd) { try { var stream = SYSCALLS.getStreamFromFD(fd); FS.close(stream); return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } function _fd_fdstat_get(fd, pbuf) { try { var rightsBase = 0; var rightsInheriting = 0; var flags = 0; { var stream = SYSCALLS.getStreamFromFD(fd); var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4 } HEAP8[pbuf] = type; HEAP16[pbuf + 2 >> 1] = flags; tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1]; tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1]; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var doReadv = (stream, iov, iovcnt, offset) => { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAPU32[iov >> 2]; var len = HEAPU32[iov + 4 >> 2]; iov += 8; var curr = FS.read(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (curr < len) break; if (typeof offset != "undefined") { offset += curr } } return ret }; function _fd_read(fd, iov, iovcnt, pnum) { try { var stream = SYSCALLS.getStreamFromFD(fd); var num = doReadv(stream, iov, iovcnt); HEAPU32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } function _fd_seek(fd, offset_low, offset_high, whence, newOffset) { var offset = convertI32PairToI53Checked(offset_low, offset_high); try { if (isNaN(offset)) return 61; var stream = SYSCALLS.getStreamFromFD(fd); FS.llseek(stream, offset, whence); tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1]; if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var doWritev = (stream, iov, iovcnt, offset) => { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAPU32[iov >> 2]; var len = HEAPU32[iov + 4 >> 2]; iov += 8; var curr = FS.write(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (typeof offset != "undefined") { offset += curr } } return ret }; function _fd_write(fd, iov, iovcnt, pnum) { try { var stream = SYSCALLS.getStreamFromFD(fd); var num = doWritev(stream, iov, iovcnt); HEAPU32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e; return e.errno } } var writeSockaddr = (sa, family, addr, port, addrlen) => { switch (family) { case 2: addr = inetPton4(addr); zeroMemory(sa, 16); if (addrlen) { HEAP32[addrlen >> 2] = 16 } HEAP16[sa >> 1] = family; HEAP32[sa + 4 >> 2] = addr; HEAP16[sa + 2 >> 1] = _htons(port); break; case 10: addr = inetPton6(addr); zeroMemory(sa, 28); if (addrlen) { HEAP32[addrlen >> 2] = 28 } HEAP32[sa >> 2] = family; HEAP32[sa + 8 >> 2] = addr[0]; HEAP32[sa + 12 >> 2] = addr[1]; HEAP32[sa + 16 >> 2] = addr[2]; HEAP32[sa + 20 >> 2] = addr[3]; HEAP16[sa + 2 >> 1] = _htons(port); break; default: return 5 }return 0 }; var _getaddrinfo = (node, service, hint, out) => { var addr = 0; var port = 0; var flags = 0; var family = 0; var type = 0; var proto = 0; var ai; function allocaddrinfo(family, type, proto, canon, addr, port) { var sa, salen, ai; var errno; salen = family === 10 ? 28 : 16; addr = family === 10 ? inetNtop6(addr) : inetNtop4(addr); sa = _malloc(salen); errno = writeSockaddr(sa, family, addr, port); assert(!errno); ai = _malloc(32); HEAP32[ai + 4 >> 2] = family; HEAP32[ai + 8 >> 2] = type; HEAP32[ai + 12 >> 2] = proto; HEAPU32[ai + 24 >> 2] = canon; HEAPU32[ai + 20 >> 2] = sa; if (family === 10) { HEAP32[ai + 16 >> 2] = 28 } else { HEAP32[ai + 16 >> 2] = 16 } HEAP32[ai + 28 >> 2] = 0; return ai } if (hint) { flags = HEAP32[hint >> 2]; family = HEAP32[hint + 4 >> 2]; type = HEAP32[hint + 8 >> 2]; proto = HEAP32[hint + 12 >> 2] } if (type && !proto) { proto = type === 2 ? 17 : 6 } if (!type && proto) { type = proto === 17 ? 2 : 1 } if (proto === 0) { proto = 6 } if (type === 0) { type = 1 } if (!node && !service) { return -2 } if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) { return -1 } if (hint !== 0 && HEAP32[hint >> 2] & 2 && !node) { return -1 } if (flags & 32) { return -2 } if (type !== 0 && type !== 1 && type !== 2) { return -7 } if (family !== 0 && family !== 2 && family !== 10) { return -6 } if (service) { service = UTF8ToString(service); port = parseInt(service, 10); if (isNaN(port)) { if (flags & 1024) { return -2 } return -8 } } if (!node) { if (family === 0) { family = 2 } if ((flags & 1) === 0) { if (family === 2) { addr = _htonl(2130706433) } else { addr = [0, 0, 0, 1] } } ai = allocaddrinfo(family, type, proto, null, addr, port); HEAPU32[out >> 2] = ai; return 0 } node = UTF8ToString(node); addr = inetPton4(node); if (addr !== null) { if (family === 0 || family === 2) { family = 2 } else if (family === 10 && flags & 8) { addr = [0, 0, _htonl(65535), addr]; family = 10 } else { return -2 } } else { addr = inetPton6(node); if (addr !== null) { if (family === 0 || family === 10) { family = 10 } else { return -2 } } } if (addr != null) { ai = allocaddrinfo(family, type, proto, node, addr, port); HEAPU32[out >> 2] = ai; return 0 } if (flags & 4) { return -2 } node = DNS.lookup_name(node); addr = inetPton4(node); if (family === 0) { family = 2 } else if (family === 10) { addr = [0, 0, _htonl(65535), addr] } ai = allocaddrinfo(family, type, proto, null, addr, port); HEAPU32[out >> 2] = ai; return 0 }; var _glActiveTexture = x0 => GLctx.activeTexture(x0); var _glAttachShader = (program, shader) => { GLctx.attachShader(GL.programs[program], GL.shaders[shader]) }; var _glBindBuffer = (target, buffer) => { GLctx.bindBuffer(target, GL.buffers[buffer]) }; var _glBindTexture = (target, texture) => { GLctx.bindTexture(target, GL.textures[texture]) }; var _glBlendFunc = (x0, x1) => GLctx.blendFunc(x0, x1); var _glBufferData = (target, size, data, usage) => { GLctx.bufferData(target, data ? HEAPU8.subarray(data, data + size) : size, usage) }; var _glClear = x0 => GLctx.clear(x0); var _glClearColor = (x0, x1, x2, x3) => GLctx.clearColor(x0, x1, x2, x3); var _glCompileShader = shader => { GLctx.compileShader(GL.shaders[shader]) }; var _glCreateProgram = () => { var id = GL.getNewId(GL.programs); var program = GLctx.createProgram(); program.name = id; program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0; program.uniformIdCounter = 1; GL.programs[id] = program; return id }; var _glCreateShader = shaderType => { var id = GL.getNewId(GL.shaders); GL.shaders[id] = GLctx.createShader(shaderType); return id }; var _glDeleteBuffers = (n, buffers) => { for (var i = 0; i < n; i++) { var id = HEAP32[buffers + i * 4 >> 2]; var buffer = GL.buffers[id]; if (!buffer) continue; GLctx.deleteBuffer(buffer); buffer.name = 0; GL.buffers[id] = null } }; var _glDeleteProgram = id => { if (!id) return; var program = GL.programs[id]; if (!program) { GL.recordError(1281); return } GLctx.deleteProgram(program); program.name = 0; GL.programs[id] = null }; var _glDeleteShader = id => { if (!id) return; var shader = GL.shaders[id]; if (!shader) { GL.recordError(1281); return } GLctx.deleteShader(shader); GL.shaders[id] = null }; var _glDeleteTextures = (n, textures) => { for (var i = 0; i < n; i++) { var id = HEAP32[textures + i * 4 >> 2]; var texture = GL.textures[id]; if (!texture) continue; GLctx.deleteTexture(texture); texture.name = 0; GL.textures[id] = null } }; var _glDisable = x0 => GLctx.disable(x0); var _glDisableVertexAttribArray = index => { GLctx.disableVertexAttribArray(index) }; var _glDrawArrays = (mode, first, count) => { GLctx.drawArrays(mode, first, count) }; var _glEnable = x0 => GLctx.enable(x0); var _glEnableVertexAttribArray = index => { GLctx.enableVertexAttribArray(index) }; var _glGenBuffers = (n, buffers) => { GL.genObject(n, buffers, "createBuffer", GL.buffers) }; var _glGenTextures = (n, textures) => { GL.genObject(n, textures, "createTexture", GL.textures) }; var _glGetAttribLocation = (program, name) => GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name)); var _glGetShaderInfoLog = (shader, maxLength, length, infoLog) => { var log = GLctx.getShaderInfoLog(GL.shaders[shader]); if (log === null) log = "(unknown error)"; var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0; if (length) HEAP32[length >> 2] = numBytesWrittenExclNull }; var _glGetShaderiv = (shader, pname, p) => { if (!p) { GL.recordError(1281); return } if (pname == 35716) { var log = GLctx.getShaderInfoLog(GL.shaders[shader]); if (log === null) log = "(unknown error)"; var logLength = log ? log.length + 1 : 0; HEAP32[p >> 2] = logLength } else if (pname == 35720) { var source = GLctx.getShaderSource(GL.shaders[shader]); var sourceLength = source ? source.length + 1 : 0; HEAP32[p >> 2] = sourceLength } else { HEAP32[p >> 2] = GLctx.getShaderParameter(GL.shaders[shader], pname) } }; var webglGetLeftBracePos = name => name.slice(-1) == "]" && name.lastIndexOf("["); var webglPrepareUniformLocationsBeforeFirstUse = program => { var uniformLocsById = program.uniformLocsById, uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, i, j; if (!uniformLocsById) { program.uniformLocsById = uniformLocsById = {}; program.uniformArrayNamesById = {}; for (i = 0; i < GLctx.getProgramParameter(program, 35718); ++i) { var u = GLctx.getActiveUniform(program, i); var nm = u.name; var sz = u.size; var lb = webglGetLeftBracePos(nm); var arrayName = lb > 0 ? nm.slice(0, lb) : nm; var id = program.uniformIdCounter; program.uniformIdCounter += sz; uniformSizeAndIdsByName[arrayName] = [sz, id]; for (j = 0; j < sz; ++j) { uniformLocsById[id] = j; program.uniformArrayNamesById[id++] = arrayName } } } }; var _glGetUniformLocation = (program, name) => { name = UTF8ToString(name); if (program = GL.programs[program]) { webglPrepareUniformLocationsBeforeFirstUse(program); var uniformLocsById = program.uniformLocsById; var arrayIndex = 0; var uniformBaseName = name; var leftBrace = webglGetLeftBracePos(name); if (leftBrace > 0) { arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; uniformBaseName = name.slice(0, leftBrace) } var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName]; if (sizeAndId && arrayIndex < sizeAndId[0]) { arrayIndex += sizeAndId[1]; if (uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name)) { return arrayIndex } } } else { GL.recordError(1281) } return -1 }; var _glLinkProgram = program => { program = GL.programs[program]; GLctx.linkProgram(program); program.uniformLocsById = 0; program.uniformSizeAndIdsByName = {} }; var _glPixelStorei = (pname, param) => { if (pname == 3317) { GL.unpackAlignment = param } GLctx.pixelStorei(pname, param) }; var _glShaderSource = (shader, count, string, length) => { var source = GL.getSource(shader, count, string, length); GLctx.shaderSource(GL.shaders[shader], source) }; var computeUnpackAlignedImageSize = (width, height, sizePerPixel, alignment) => { function roundedToNextMultipleOf(x, y) { return x + y - 1 & -y } var plainRowSize = width * sizePerPixel; var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment); return height * alignedRowSize }; var colorChannelsInGlTextureFormat = format => { var colorChannels = { 5: 3, 6: 4, 8: 2, 29502: 3, 29504: 4 }; return colorChannels[format - 6402] || 1 }; var heapObjectForWebGLType = type => { type -= 5120; if (type == 1) return HEAPU8; if (type == 4) return HEAP32; if (type == 6) return HEAPF32; if (type == 5 || type == 28922) return HEAPU32; return HEAPU16 }; var toTypedArrayIndex = (pointer, heap) => pointer >>> 31 - Math.clz32(heap.BYTES_PER_ELEMENT); var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => { var heap = heapObjectForWebGLType(type); var sizePerPixel = colorChannelsInGlTextureFormat(format) * heap.BYTES_PER_ELEMENT; var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment); return heap.subarray(toTypedArrayIndex(pixels, heap), toTypedArrayIndex(pixels + bytes, heap)) }; var _glTexImage2D = (target, level, internalFormat, width, height, border, format, type, pixels) => { var pixelData = pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null; GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixelData) }; var _glTexParameteri = (x0, x1, x2) => GLctx.texParameteri(x0, x1, x2); var webglGetUniformLocation = location => { var p = GLctx.currentProgram; if (p) { var webglLoc = p.uniformLocsById[location]; if (typeof webglLoc == "number") { p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : "")) } return webglLoc } else { GL.recordError(1282) } }; var _glUniform1f = (location, v0) => { GLctx.uniform1f(webglGetUniformLocation(location), v0) }; var _glUniform1i = (location, v0) => { GLctx.uniform1i(webglGetUniformLocation(location), v0) }; var _glUniform3f = (location, v0, v1, v2) => { GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2) }; var miniTempWebGLFloatBuffers = []; var _glUniformMatrix4fv = (location, count, transpose, value) => { if (count <= 18) { var view = miniTempWebGLFloatBuffers[16 * count]; var heap = HEAPF32; value = value >> 2; for (var i = 0; i < 16 * count; i += 16) { var dst = value + i; view[i] = heap[dst]; view[i + 1] = heap[dst + 1]; view[i + 2] = heap[dst + 2]; view[i + 3] = heap[dst + 3]; view[i + 4] = heap[dst + 4]; view[i + 5] = heap[dst + 5]; view[i + 6] = heap[dst + 6]; view[i + 7] = heap[dst + 7]; view[i + 8] = heap[dst + 8]; view[i + 9] = heap[dst + 9]; view[i + 10] = heap[dst + 10]; view[i + 11] = heap[dst + 11]; view[i + 12] = heap[dst + 12]; view[i + 13] = heap[dst + 13]; view[i + 14] = heap[dst + 14]; view[i + 15] = heap[dst + 15] } } else { var view = HEAPF32.subarray(value >> 2, value + count * 64 >> 2) } GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view) }; var _glUseProgram = program => { program = GL.programs[program]; GLctx.useProgram(program); GLctx.currentProgram = program }; var _glValidateProgram = program => { GLctx.validateProgram(GL.programs[program]) }; var _glVertexAttribPointer = (index, size, type, normalized, stride, ptr) => { GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr) }; var _glViewport = (x0, x1, x2, x3) => GLctx.viewport(x0, x1, x2, x3); var _llvm_eh_typeid_for = type => type; var arraySum = (array, index) => { var sum = 0; for (var i = 0; i <= index; sum += array[i++]) { } return sum }; var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; var addDays = (date, days) => { var newDate = new Date(date.getTime()); while (days > 0) { var leap = isLeapYear(newDate.getFullYear()); var currentMonth = newDate.getMonth(); var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth]; if (days > daysInCurrentMonth - newDate.getDate()) { days -= daysInCurrentMonth - newDate.getDate() + 1; newDate.setDate(1); if (currentMonth < 11) { newDate.setMonth(currentMonth + 1) } else { newDate.setMonth(0); newDate.setFullYear(newDate.getFullYear() + 1) } } else { newDate.setDate(newDate.getDate() + days); return newDate } } return newDate }; var writeArrayToMemory = (array, buffer) => { assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)"); HEAP8.set(array, buffer) }; var _strftime = (s, maxsize, format, tm) => { var tm_zone = HEAPU32[tm + 40 >> 2]; var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" }; var pattern = UTF8ToString(format); var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }; for (var rule in EXPANSION_RULES_1) { pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]) } var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]; var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; function leadingSomething(value, digits, character) { var str = typeof value == "number" ? value.toString() : value || ""; while (str.length < digits) { str = character[0] + str } return str } function leadingNulls(value, digits) { return leadingSomething(value, digits, "0") } function compareByDay(date1, date2) { function sgn(value) { return value < 0 ? -1 : value > 0 ? 1 : 0 } var compare; if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) { if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) { compare = sgn(date1.getDate() - date2.getDate()) } } return compare } function getFirstWeekStartDate(janFourth) { switch (janFourth.getDay()) { case 0: return new Date(janFourth.getFullYear() - 1, 11, 29); case 1: return janFourth; case 2: return new Date(janFourth.getFullYear(), 0, 3); case 3: return new Date(janFourth.getFullYear(), 0, 2); case 4: return new Date(janFourth.getFullYear(), 0, 1); case 5: return new Date(janFourth.getFullYear() - 1, 11, 31); case 6: return new Date(janFourth.getFullYear() - 1, 11, 30) } } function getWeekBasedYear(date) { var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4); var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4); var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear); var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) { if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) { return thisDate.getFullYear() + 1 } return thisDate.getFullYear() } return thisDate.getFullYear() - 1 } var EXPANSION_RULES_2 = { "%a": date => WEEKDAYS[date.tm_wday].substring(0, 3), "%A": date => WEEKDAYS[date.tm_wday], "%b": date => MONTHS[date.tm_mon].substring(0, 3), "%B": date => MONTHS[date.tm_mon], "%C": date => { var year = date.tm_year + 1900; return leadingNulls(year / 100 | 0, 2) }, "%d": date => leadingNulls(date.tm_mday, 2), "%e": date => leadingSomething(date.tm_mday, 2, " "), "%g": date => getWeekBasedYear(date).toString().substring(2), "%G": getWeekBasedYear, "%H": date => leadingNulls(date.tm_hour, 2), "%I": date => { var twelveHour = date.tm_hour; if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12; return leadingNulls(twelveHour, 2) }, "%j": date => leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3), "%m": date => leadingNulls(date.tm_mon + 1, 2), "%M": date => leadingNulls(date.tm_min, 2), "%n": () => "\n", "%p": date => { if (date.tm_hour >= 0 && date.tm_hour < 12) { return "AM" } return "PM" }, "%S": date => leadingNulls(date.tm_sec, 2), "%t": () => "\t", "%u": date => date.tm_wday || 7, "%U": date => { var days = date.tm_yday + 7 - date.tm_wday; return leadingNulls(Math.floor(days / 7), 2) }, "%V": date => { var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7); if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) { val++ } if (!val) { val = 52; var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7; if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) { val++ } } else if (val == 53) { var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7; if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1 } return leadingNulls(val, 2) }, "%w": date => date.tm_wday, "%W": date => { var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7; return leadingNulls(Math.floor(days / 7), 2) }, "%y": date => (date.tm_year + 1900).toString().substring(2), "%Y": date => date.tm_year + 1900, "%z": date => { var off = date.tm_gmtoff; var ahead = off >= 0; off = Math.abs(off) / 60; off = off / 60 * 100 + off % 60; return (ahead ? "+" : "-") + String("0000" + off).slice(-4) }, "%Z": date => date.tm_zone, "%%": () => "%" }; pattern = pattern.replace(/%%/g, "\0\0"); for (var rule in EXPANSION_RULES_2) { if (pattern.includes(rule)) { pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date)) } } pattern = pattern.replace(/\0\0/g, "%"); var bytes = intArrayFromString(pattern, false); if (bytes.length > maxsize) { return 0 } writeArrayToMemory(bytes, s); return bytes.length - 1 }; var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm); var stringToUTF8OnStack = str => { var size = lengthBytesUTF8(str) + 1; var ret = stackAlloc(size); stringToUTF8(str, ret, size); return ret }; var getCFunc = ident => { var func = Module["_" + ident]; assert(func, "Cannot call unknown function " + ident + ", make sure it is exported"); return func }; var ccall = (ident, returnType, argTypes, args, opts) => { var toC = { "string": str => { var ret = 0; if (str !== null && str !== undefined && str !== 0) { ret = stringToUTF8OnStack(str) } return ret }, "array": arr => { var ret = stackAlloc(arr.length); writeArrayToMemory(arr, ret); return ret } }; function convertReturnValue(ret) { if (returnType === "string") { return UTF8ToString(ret) } if (returnType === "boolean") return Boolean(ret); return ret } var func = getCFunc(ident); var cArgs = []; var stack = 0; assert(returnType !== "array", 'Return type should not be "array".'); if (args) { for (var i = 0; i < args.length; i++) { var converter = toC[argTypes[i]]; if (converter) { if (stack === 0) stack = stackSave(); cArgs[i] = converter(args[i]) } else { cArgs[i] = args[i] } } } var ret = func(...cArgs); function onDone(ret) { if (stack !== 0) stackRestore(stack); return convertReturnValue(ret) } ret = onDone(ret); return ret }; var cwrap = (ident, returnType, argTypes, opts) => (...args) => ccall(ident, returnType, argTypes, args, opts); FS.createPreloadedFile = FS_createPreloadedFile; FS.staticInit(); var GLctx; Fetch.init(); var miniTempWebGLFloatBuffersStorage = new Float32Array(288); for (var i = 0; i < 288; ++i) { miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i) } function checkIncomingModuleAPI() { ignoredModuleProp("fetchSettings") } var wasmImports = { __assert_fail: ___assert_fail, __cxa_begin_catch: ___cxa_begin_catch, __cxa_end_catch: ___cxa_end_catch, __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2, __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3, __cxa_find_matching_catch_4: ___cxa_find_matching_catch_4, __cxa_find_matching_catch_5: ___cxa_find_matching_catch_5, __cxa_find_matching_catch_6: ___cxa_find_matching_catch_6, __cxa_rethrow: ___cxa_rethrow, __cxa_throw: ___cxa_throw, __cxa_uncaught_exceptions: ___cxa_uncaught_exceptions, __resumeException: ___resumeException, __syscall_connect: ___syscall_connect, __syscall_faccessat: ___syscall_faccessat, __syscall_fcntl64: ___syscall_fcntl64, __syscall_fstat64: ___syscall_fstat64, __syscall_ioctl: ___syscall_ioctl, __syscall_lstat64: ___syscall_lstat64, __syscall_newfstatat: ___syscall_newfstatat, __syscall_openat: ___syscall_openat, __syscall_renameat: ___syscall_renameat, __syscall_rmdir: ___syscall_rmdir, __syscall_sendto: ___syscall_sendto, __syscall_socket: ___syscall_socket, __syscall_stat64: ___syscall_stat64, __syscall_unlinkat: ___syscall_unlinkat, _abort_js: __abort_js, _emscripten_fetch_free: __emscripten_fetch_free, _emscripten_fetch_get_response_headers: __emscripten_fetch_get_response_headers, _emscripten_fetch_get_response_headers_length: __emscripten_fetch_get_response_headers_length, _emscripten_memcpy_js: __emscripten_memcpy_js, _emscripten_throw_longjmp: __emscripten_throw_longjmp, _gmtime_js: __gmtime_js, _localtime_js: __localtime_js, _mktime_js: __mktime_js, _tzset_js: __tzset_js, emscripten_asm_const_int: _emscripten_asm_const_int, emscripten_console_error: _emscripten_console_error, emscripten_console_log: _emscripten_console_log, emscripten_console_warn: _emscripten_console_warn, emscripten_date_now: _emscripten_date_now, emscripten_err: _emscripten_err, emscripten_get_element_css_size: _emscripten_get_element_css_size, emscripten_idb_async_load: _emscripten_idb_async_load, emscripten_is_main_browser_thread: _emscripten_is_main_browser_thread, emscripten_is_webgl_context_lost: _emscripten_is_webgl_context_lost, emscripten_request_animation_frame: _emscripten_request_animation_frame, emscripten_resize_heap: _emscripten_resize_heap, emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size, emscripten_set_mousedown_callback_on_thread: _emscripten_set_mousedown_callback_on_thread, emscripten_set_mousemove_callback_on_thread: _emscripten_set_mousemove_callback_on_thread, emscripten_set_mouseup_callback_on_thread: _emscripten_set_mouseup_callback_on_thread, emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread, emscripten_set_timeout: _emscripten_set_timeout, emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread, emscripten_start_fetch: _emscripten_start_fetch, emscripten_webgl_create_context: _emscripten_webgl_create_context, emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context, emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current, environ_get: _environ_get, environ_sizes_get: _environ_sizes_get, exit: _exit, fd_close: _fd_close, fd_fdstat_get: _fd_fdstat_get, fd_read: _fd_read, fd_seek: _fd_seek, fd_write: _fd_write, getaddrinfo: _getaddrinfo, glActiveTexture: _glActiveTexture, glAttachShader: _glAttachShader, glBindBuffer: _glBindBuffer, glBindTexture: _glBindTexture, glBlendFunc: _glBlendFunc, glBufferData: _glBufferData, glClear: _glClear, glClearColor: _glClearColor, glCompileShader: _glCompileShader, glCreateProgram: _glCreateProgram, glCreateShader: _glCreateShader, glDeleteBuffers: _glDeleteBuffers, glDeleteProgram: _glDeleteProgram, glDeleteShader: _glDeleteShader, glDeleteTextures: _glDeleteTextures, glDisable: _glDisable, glDisableVertexAttribArray: _glDisableVertexAttribArray, glDrawArrays: _glDrawArrays, glEnable: _glEnable, glEnableVertexAttribArray: _glEnableVertexAttribArray, glGenBuffers: _glGenBuffers, glGenTextures: _glGenTextures, glGetAttribLocation: _glGetAttribLocation, glGetShaderInfoLog: _glGetShaderInfoLog, glGetShaderiv: _glGetShaderiv, glGetUniformLocation: _glGetUniformLocation, glLinkProgram: _glLinkProgram, glPixelStorei: _glPixelStorei, glShaderSource: _glShaderSource, glTexImage2D: _glTexImage2D, glTexParameteri: _glTexParameteri, glUniform1f: _glUniform1f, glUniform1i: _glUniform1i, glUniform3f: _glUniform3f, glUniformMatrix4fv: _glUniformMatrix4fv, glUseProgram: _glUseProgram, glValidateProgram: _glValidateProgram, glVertexAttribPointer: _glVertexAttribPointer, glViewport: _glViewport, invoke_di: invoke_di, invoke_dii: invoke_dii, invoke_diii: invoke_diii, invoke_fiii: invoke_fiii, invoke_i: invoke_i, invoke_id: invoke_id, invoke_if: invoke_if, invoke_ii: invoke_ii, invoke_iid: invoke_iid, invoke_iidddd: invoke_iidddd, invoke_iidi: invoke_iidi, invoke_iif: invoke_iif, invoke_iii: invoke_iii, invoke_iiidii: invoke_iiidii, invoke_iiii: invoke_iiii, invoke_iiiid: invoke_iiiid, invoke_iiiii: invoke_iiiii, invoke_iiiiid: invoke_iiiiid, invoke_iiiiii: invoke_iiiiii, invoke_iiiiiii: invoke_iiiiiii, invoke_iiiiiiii: invoke_iiiiiiii, invoke_iiiiiiiid: invoke_iiiiiiiid, invoke_iiiiiiiii: invoke_iiiiiiiii, invoke_iiiiiiiiiii: invoke_iiiiiiiiiii, invoke_iiiiiiiiiiii: invoke_iiiiiiiiiiii, invoke_iiiiiiiiiiiii: invoke_iiiiiiiiiiiii, invoke_iiiiiiiiiiiiiiiiiiiddiiiiiiiii: invoke_iiiiiiiiiiiiiiiiiiiddiiiiiiiii, invoke_iiiiij: invoke_iiiiij, invoke_iiij: invoke_iiij, invoke_iiijii: invoke_iiijii, invoke_iij: invoke_iij, invoke_ji: invoke_ji, invoke_jiiii: invoke_jiiii, invoke_jiij: invoke_jiij, invoke_jij: invoke_jij, invoke_v: invoke_v, invoke_vi: invoke_vi, invoke_vid: invoke_vid, invoke_vidd: invoke_vidd, invoke_viddd: invoke_viddd, invoke_vif: invoke_vif, invoke_viff: invoke_viff, invoke_vifff: invoke_vifff, invoke_viffi: invoke_viffi, invoke_vii: invoke_vii, invoke_viid: invoke_viid, invoke_viidd: invoke_viidd, invoke_viii: invoke_viii, invoke_viiii: invoke_viiii, invoke_viiiid: invoke_viiiid, invoke_viiiii: invoke_viiiii, invoke_viiiiiffi: invoke_viiiiiffi, invoke_viiiiii: invoke_viiiiii, invoke_viiiiiii: invoke_viiiiiii, invoke_viiiiiiiff: invoke_viiiiiiiff, invoke_viiiiiiii: invoke_viiiiiiii, invoke_viiiiiiiii: invoke_viiiiiiiii, invoke_viiiiiiiiii: invoke_viiiiiiiiii, invoke_viiiiiiiiiii: invoke_viiiiiiiiiii, invoke_viiiiiiiiiiii: invoke_viiiiiiiiiiii, invoke_viiiiiiiiiiiii: invoke_viiiiiiiiiiiii, invoke_viiiiiiiiiiiiiii: invoke_viiiiiiiiiiiiiii, invoke_viij: invoke_viij, invoke_viijii: invoke_viijii, llvm_eh_typeid_for: _llvm_eh_typeid_for, strftime: _strftime, strftime_l: _strftime_l }; var wasmExports = createWasm(); var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors", 0); var ___cxa_free_exception = createExportWrapper("__cxa_free_exception", 1); var _main = Module["_main"] = createExportWrapper("__main_argc_argv", 2); var _Initialize = Module["_Initialize"] = createExportWrapper("Initialize", 1); var _SetArgument = Module["_SetArgument"] = createExportWrapper("SetArgument", 2); var _test = Module["_test"] = createExportWrapper("test", 2); var _process_blob = Module["_process_blob"] = createExportWrapper("process_blob", 2); var _read_from_idb = Module["_read_from_idb"] = createExportWrapper("read_from_idb", 2); var _free = createExportWrapper("free", 1); var _malloc = createExportWrapper("malloc", 1); var _fflush = createExportWrapper("fflush", 1); var _ntohs = createExportWrapper("ntohs", 1); var _htons = createExportWrapper("htons", 1); var _htonl = createExportWrapper("htonl", 1); var _setThrew = createExportWrapper("setThrew", 2); var __emscripten_tempret_set = createExportWrapper("_emscripten_tempret_set", 1); var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports["emscripten_stack_init"])(); var _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports["emscripten_stack_get_free"])(); var _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports["emscripten_stack_get_base"])(); var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])(); var __emscripten_stack_restore = a0 => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(a0); var __emscripten_stack_alloc = a0 => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0); var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])(); var ___cxa_decrement_exception_refcount = createExportWrapper("__cxa_decrement_exception_refcount", 1); var ___cxa_increment_exception_refcount = createExportWrapper("__cxa_increment_exception_refcount", 1); var ___get_exception_message = createExportWrapper("__get_exception_message", 3); var ___cxa_can_catch = createExportWrapper("__cxa_can_catch", 3); var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type", 1); var dynCall_iiijii = Module["dynCall_iiijii"] = createExportWrapper("dynCall_iiijii", 7); var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji", 2); var dynCall_viijii = Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii", 7); var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij", 4); var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij", 5); var dynCall_jiij = Module["dynCall_jiij"] = createExportWrapper("dynCall_jiij", 5); var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij", 4); var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij", 4); var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij", 5); var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji", 6); var dynCall_viiiji = Module["dynCall_viiiji"] = createExportWrapper("dynCall_viiiji", 7); var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji", 5); var dynCall_iiiiij = Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij", 7); var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii", 5); var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj", 9); var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj", 10); function invoke_viii(index, a1, a2, a3) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiii(index, a1, a2, a3, a4, a5) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_vi(index, a1) { var sp = stackSave(); try { getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iii(index, a1, a2) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiii(index, a1, a2, a3, a4) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiii(index, a1, a2, a3) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_vii(index, a1, a2) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_ii(index, a1) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_v(index) { var sp = stackSave(); try { getWasmTableEntry(index)() } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_i(index) { var sp = stackSave(); try { return getWasmTableEntry(index)() } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiii(index, a1, a2, a3, a4, a5) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiii(index, a1, a2, a3, a4) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_vidd(index, a1, a2, a3) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_vid(index, a1, a2) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iid(index, a1, a2) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viffi(index, a1, a2, a3, a4) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iif(index, a1, a2) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viff(index, a1, a2, a3) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_dii(index, a1, a2) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiid(index, a1, a2, a3, a4, a5) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viidd(index, a1, a2, a3, a4) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_di(index, a1) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiid(index, a1, a2, a3, a4) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiid(index, a1, a2, a3, a4, a5, a6, a7, a8) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iidddd(index, a1, a2, a3, a4, a5) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viddd(index, a1, a2, a3, a4) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiidii(index, a1, a2, a3, a4, a5) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiff(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_id(index, a1) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_if(index, a1) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiiiiiiiiiiiiiddiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iidi(index, a1, a2, a3) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_vif(index, a1, a2) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiffi(index, a1, a2, a3, a4, a5, a6, a7, a8) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_vifff(index, a1, a2, a3, a4) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viid(index, a1, a2, a3) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiid(index, a1, a2, a3, a4, a5) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_fiii(index, a1, a2, a3) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_diii(index, a1, a2, a3) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) { var sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) { var sp = stackSave(); try { getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiijii(index, a1, a2, a3, a4, a5, a6) { var sp = stackSave(); try { return dynCall_iiijii(index, a1, a2, a3, a4, a5, a6) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_ji(index, a1) { var sp = stackSave(); try { return dynCall_ji(index, a1) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iij(index, a1, a2, a3) { var sp = stackSave(); try { return dynCall_iij(index, a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viijii(index, a1, a2, a3, a4, a5, a6) { var sp = stackSave(); try { dynCall_viijii(index, a1, a2, a3, a4, a5, a6) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiij(index, a1, a2, a3, a4) { var sp = stackSave(); try { return dynCall_iiij(index, a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_jij(index, a1, a2, a3) { var sp = stackSave(); try { return dynCall_jij(index, a1, a2, a3) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_jiij(index, a1, a2, a3, a4) { var sp = stackSave(); try { return dynCall_jiij(index, a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_viij(index, a1, a2, a3, a4) { var sp = stackSave(); try { dynCall_viij(index, a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_iiiiij(index, a1, a2, a3, a4, a5, a6) { var sp = stackSave(); try { return dynCall_iiiiij(index, a1, a2, a3, a4, a5, a6) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } function invoke_jiiii(index, a1, a2, a3, a4) { var sp = stackSave(); try { return dynCall_jiiii(index, a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (!(e instanceof EmscriptenEH)) throw e; _setThrew(1, 0) } } Module["ccall"] = ccall; Module["cwrap"] = cwrap; var missingLibrarySymbols = ["writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "convertI32PairToI53", "convertU32PairToI53", "getTempRet0", "emscriptenLog", "runMainThreadEmAsm", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "runtimeKeepalivePush", "runtimeKeepalivePop", "asmjsMangle", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "stringToNewUTF8", "registerKeyEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "jsStackTrace", "getCallstack", "convertPCtoSourceLocation", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "Browser_asyncPrepareDataCounter", "setMainLoop", "FS_unlink", "FS_mkdirTree", "_setNetworkCallback", "emscriptenWebGLGet", "emscriptenWebGLGetUniform", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory", "setErrNo", "demangle", "stackTrace"]; missingLibrarySymbols.forEach(missingLibrarySymbol); var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_readFile", "out", "err", "callMain", "abort", "wasmMemory", "wasmExports", "writeStackCookie", "checkStackCookie", "writeI53ToI64", "readI53FromI64", "readI53FromU64", "convertI32PairToI53Checked", "stackSave", "stackRestore", "stackAlloc", "setTempRet0", "ptrToString", "zeroMemory", "exitJS", "getHeapMax", "growMemory", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "readEmAsmArgsArray", "readEmAsmArgs", "runEmAsmFunction", "jstoi_q", "jstoi_s", "getExecutableName", "handleException", "keepRuntimeAlive", "callUserCallback", "maybeExit", "asyncLoad", "alignMemory", "mmapAlloc", "HandleAllocator", "wasmTable", "noExitRuntime", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "currentFullscreenStrategy", "restoreOldWindowedStyle", "UNWIND_CACHE", "ExitStatus", "getEnvStrings", "doReadv", "doWritev", "safeSetTimeout", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "findMatchingCatch", "getExceptionMessageCommon", "incrementExceptionRefcount", "decrementExceptionRefcount", "getExceptionMessage", "Browser", "getPreloadedImageData__data", "wget", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "preloadPlugins", "FS_createPreloadedFile", "FS_modeStringToFlags", "FS_getMode", "FS_stdin_getChar_buffer", "FS_stdin_getChar", "FS", "FS_createDataFile", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "heapObjectForWebGLType", "toTypedArrayIndex", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "GL", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "allocateUTF8", "allocateUTF8OnStack", "Fetch", "fetchDeleteCachedData", "fetchLoadCachedData", "fetchCacheData", "fetchXHR"]; unexportedSymbols.forEach(unexportedRuntimeSymbol); var calledRun; dependenciesFulfilled = function runCaller() { if (!calledRun) run(); if (!calledRun) dependenciesFulfilled = runCaller }; function callMain(args = []) { assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])'); assert(__ATPRERUN__.length == 0, "cannot call main when preRun functions remain to be called"); var entryFunction = _main; args.unshift(thisProgram); var argc = args.length; var argv = stackAlloc((argc + 1) * 4); var argv_ptr = argv; args.forEach(arg => { HEAPU32[argv_ptr >> 2] = stringToUTF8OnStack(arg); argv_ptr += 4 }); HEAPU32[argv_ptr >> 2] = 0; try { var ret = entryFunction(argc, argv); exitJS(ret, true); return ret } catch (e) { return handleException(e) } } function stackCheckInit() { _emscripten_stack_init(); writeStackCookie() } function run(args = arguments_) { if (runDependencies > 0) { return } stackCheckInit(); preRun(); if (runDependencies > 0) { return } function doRun() { if (calledRun) return; calledRun = true; Module["calledRun"] = true; if (ABORT) return; initRuntime(); preMain(); readyPromiseResolve(Module); if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"](); if (shouldRunNow) callMain(args); postRun() } if (Module["setStatus"]) { Module["setStatus"]("Running..."); setTimeout(function () { setTimeout(function () { Module["setStatus"]("") }, 1); doRun() }, 1) } else { doRun() } checkStackCookie() } function checkUnflushedContent() { var oldOut = out; var oldErr = err; var has = false; out = err = x => { has = true }; try { _fflush(0);["stdout", "stderr"].forEach(function (name) { var info = FS.analyzePath("/dev/" + name); if (!info) return; var stream = info.object; var rdev = stream.rdev; var tty = TTY.ttys[rdev]; if (tty?.output?.length) { has = true } }) } catch (e) { } out = oldOut; err = oldErr; if (has) { warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.") } } if (Module["preInit"]) { if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]]; while (Module["preInit"].length > 0) { Module["preInit"].pop()() } } var shouldRunNow = true; if (Module["noInitialRun"]) shouldRunNow = false; run(); moduleRtn = readyPromise; for (const prop of Object.keys(Module)) { if (!(prop in moduleArg)) { Object.defineProperty(moduleArg, prop, { configurable: true, get() { abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`) } }) } }


      return moduleRtn;
    }
  );
})();
export default RtViewer;
